{"version":3,"file":"p5.rxtx.es.js","sources":["../src/rxtx.processing.js","../src/rxtx.serial.data.js","../src/rxtx.serial.port.js","../src/rxtx.serial.js","../src/rxtx.window.js","../src/rxtx.keyboard.js","../src/rxtx.debug.js","../src/rxtx.init.js","../src/main.js"],"sourcesContent":["/**\n * Parses a JSON string and returns the resulting object.\n * If parsing fails, it returns a default object with an `id` of -1.\n *\n * @param {string} theString - The JSON string to be parsed.\n * @returns {Object} - The parsed JSON object, or a default object \n * if parsing fails.\n */\nexport const parseStringToJSON = async (theString) => {\n  try {\n    let json = JSON.parse(theString);\n    return json;\n  } catch (error) {\n    return { id: -1 };\n  }\n};\n\n/**\n * Parses a string into an array of numbers or a single floating-point \n * number. If the string starts with '[', it is treated as a comma-separated \n * list of numbers. Otherwise, the string is parsed as a single float.\n *\n * @param {string} theData - The input string to be parsed.\n * @returns {number[]|number} - An array of numbers if the input represents a \n * list, or a single floating-point number if it does not.\n *\n * @example\n * parseStringToArray(\"[1, 2, 3]\"); // Returns [1, 2, 3]\n * parseStringToArray(\"42.5\");     // Returns 42.5\n */\nexport const parseStringToArray = (theData) => {\n  if (theData.charAt(0) == \"[\") {\n    let str0 = theData;\n    let str1 = str0.trim().replace(/[`\\[\\]\\\\\\/]/gi, \"\");\n    let arr0 = str1.split(\",\");\n    let arr1 = arr0.map(Number);\n    return arr1;\n  } else {\n    // @TODO do we want that here or should this default\n    // to an array with a single element.\n    return float(theData);\n  }\n};\n\n/**\n * Converts a string to an ArrayBuffer.\n *\n * This function takes a string and encodes it into an ArrayBuffer where each \n * character is represented by 2 bytes (UTF-16). The resulting ArrayBuffer can \n * be used for binary data manipulation.\n *\n * @param {string} theString - The input string to be converted.\n * @returns {ArrayBuffer} The resulting ArrayBuffer containing the encoded string.\n *\n * Example:\n * const buffer = str2ab(\"hello\");\n * console.log(buffer); // ArrayBuffer { byteLength: 10 }\n */\nexport const str2ab = (theString) => {\n  var buf = new ArrayBuffer(theString.length * 2); // 2 bytes for each char\n  var bufView = new Uint16Array(buf);\n  for (var i = 0, strLen = theString.length; i < strLen; i++) {\n    bufView[i] = theString.charCodeAt(i);\n  }\n  return buf;\n};\n\n/**\n * Recursively merges the properties of a source object into a target object.\n * If a property in the source is an object, it performs a deep merge. Arrays\n * are not deeply merged but overwritten. The target object is modified and\n * returned.\n *\n * @param {Object} target - The object to receive properties from the source.\n * @param {Object} source - The object whose properties are merged into the\n * target.\n * @returns {Object} - The modified target object after merging.\n *\n * @example\n * const target = { a: 1, b: { c: 2 } };\n * const source = { b: { d: 3 }, e: 4 };\n * const result = deepMerge(target, source);\n * console.log(result); // { a: 1, b: { c: 2, d: 3 }, e: 4 }\n */\nexport const deepMerge = (target, source) => {\n  for (const key in source) {\n    if (\n      source[key] && typeof source[key] === \"object\" &&\n      !Array.isArray(source[key])\n    ) {\n      target[key] = deepMerge(target[key] || {}, source[key]);\n    } else {\n      target[key] = source[key];\n    }\n  }\n  return target;\n};\n\n/**\n * Updates the given state object with new properties.\n * \n * This function merges the `updates` object into `theState` using\n * shallow copying. Existing properties in `theState` are overwritten \n * if they exist in `updates`, while new properties are added.\n * \n * @param {Object} theState - The state object to update.\n * @param {Object} updates - The object containing properties to merge\n *                           into the state.\n * \n * @example\n * const state = { a: 1, b: 2 };\n * updateState(state, { b: 3, c: 4 });\n * console.log(state); // { a: 1, b: 3, c: 4 }\n */\nexport const updateState = (theState, updates) => {\n  Object.assign(theState, updates);\n};\n\n/**\n * Generates a formatted timestamp string.\n *\n * This function constructs a timestamp in the format `YYYYMMDDHHmmSS` using\n * the current date and time. Each component (month, day, hour, minute, and\n * second) is zero-padded to ensure a consistent two-digit format.\n *\n * @returns {string} A timestamp string in the format `YYYYMMDDHHmmSS`.\n *\n * Example:\n *   If the current date and time is December 1, 2023, 15:05:09, the output\n *   will be: \"20231201150509\".\n */\nexport const getFormattedTimeStamp = () => {\n  let t = year() + nf(month(), 2) + nf(day(), 2);\n  t += nf(hour(), 2) + nf(minute(), 2) + nf(second(), 2);\n  return t;\n};\n","import { parseStringToJSON, updateState } from \"./rxtx.processing\";\n\n/**\n * Sends data to the connected serial device via the Web Serial API.\n *\n * @async\n * @function rxtxWriteTo\n * @param {Object} theState - The current application state, including the\n *                            serial port and writer.\n * @param {*} theData - The data to be sent to the serial device. This data\n *                      will be processed before being written.\n * @returns {Promise<boolean>} Returns true if the data was successfully sent,\n *                             or false if no port is available in the state.\n *\n * @example\n * const state = { port: somePort, writer: someWriter };\n * const success = await rxtxWriteTo(state, \"Hello Device\");\n * console.log(success); // true if data was sent successfully\n */\nexport const rxtxWriteTo = async (theState, theData) => {\n  if (!theState?.port) return false;\n  await theState.writer.write(checkRxtxData(theData));\n  return true;\n};\n\nconst checkRxtxData = (theData) => {\n  // see sketch https://editor.p5js.org/sojamo/sketches/yXZauy17X\n  // to type check, then operate on theData accordingly\n  // and return expected type so that it can be interpreted\n  // by the receiving end, the Arduino.\n  return utf8EncodeText.encode(theData);\n};\n\n/**\n * Processes incoming data from a serial stream, handling partial and complete\n * data chunks. Appends incomplete data to a buffer until a newline character\n * (`\\n`) is detected, at which point the buffer is parsed as JSON. Updates the\n * application state and triggers related events upon successful parsing.\n *\n * @param {string} value - Incoming data chunk from the serial stream.\n * @param {object} theState - Application state object that holds the buffer,\n *                            parsed data, and callback functions.\n *\n * @throws {Error} Logs an error if parsing the buffer as JSON fails.\n *\n * @example\n * handleIncomingData(\"[1,2,3]\\n\", theState);\n * // Parses \"[1,2,3]\" as JSON, updates the state, and triggers events.\n */\nexport const handleIncomingData = (value, theState) => {\n  if (!value.includes(\"\\n\")) {\n    theState.readBuffer += value;\n    return;\n  }\n  const [data, remainder] = value.split(\"\\n\");\n  theState.readBuffer += data;\n  parseStringToJSON(theState.readBuffer)\n    .then((parsedData) => {\n      if (parsedData.value !== undefined) {\n        // @TODO fix this messy looking data transfer\n        const { id, value } = parsedData;\n        theState.debug.data = { value, id };\n        updateState(theState, {\n          value: value || [],\n          id: id || -1,\n          // debug: { data: theState }, // @TODO look into this assignment, overrides debug settings\n        });\n\n        theState.fn({ id: theState.id, value: theState.value });\n        theState.rxtxEvent({ id: theState.id, value: theState.value });\n      }\n      theState.readBuffer = remainder || \"\";\n    })\n    .catch((err) => console.log(\"Error parsing data:\", err));\n};\n","import { handleIncomingData } from \"./rxtx.serial.data\";\nimport { updateState } from \"./rxtx.processing\";\n\n/**\n * Retrieves all available serial ports that the user has\n * previously granted permission to access.\n *\n * This function utilizes the Web Serial API to list serial\n * ports that are currently available and for which the browser\n * has retained user permissions. If the Web Serial API is not\n * supported by the browser, an error is thrown.\n *\n * @async\n * @function getAvailablePorts\n * @throws {Error} If the Web Serial API is not supported by the browser.\n * @returns {Promise<SerialPort[]>} A promise that resolves to an array\n *                                  of `SerialPort` objects representing\n *                                  the available serial ports.\n */\nexport const getAvailablePorts = async () => {\n  if (!(\"serial\" in navigator)) {\n    throw new Error(\"Web Serial API not supported.\");\n  }\n  return await navigator.serial.getPorts();\n};\n\n/**\n * Attempts to reconnect to all previously granted serial ports.\n *\n * This function retrieves a list of previously granted serial ports using\n * `getAvailablePorts`, then iterates over each port to establish a connection\n * by calling `connectToPort`. The state (`theState`) is updated during each\n * connection attempt.\n *\n * @async\n * @param {Object} theState - The application state object used to manage\n *                            connections and serial port details.\n */\nexport const reconnectToPreviouslyGrantedPorts = async (theState) => {\n  const ports = await getAvailablePorts();\n  console.log(\"trying to reconnect to previous ports\", ports);\n  for (const port of ports) {\n    await connectToPort(port, theState);\n  }\n};\n\n/**\n * Checks and establishes a connection to a serial port for the given state.\n *\n * This function initializes the `readBuffer` in the provided state and attempts\n * to retrieve available serial ports. If no ports are available, it prompts\n * the user to select a port. Otherwise, it selects the first available port.\n * Once a port is identified, the function attempts to connect to it.\n *\n * @async\n * @function checkPortConnectionFor\n * @param {Object} theState - The application state object. It should contain\n *                            the required properties for managing the serial\n *                            connection and the read buffer.\n * @returns {Promise<boolean>} - Resolves to `true` if the connection is\n *                               successfully established; otherwise, `false`.\n */\nexport const checkPortConnectionFor = async (theState) => {\n  theState.readBuffer = \"\";\n\n  // Get available ports\n  const ports = await getAvailablePorts();\n\n  let port;\n  if (ports.length === 0) {\n    // Select a port if none are available\n    port = await selectPort();\n  } else {\n    // Select the first port available from the ports list\n    port = ports[0];\n  }\n  return await connectToPort(port, theState);\n};\n\n/**\n * Prompts the user to select a serial port using the Web Serial API.\n *\n * This function uses `navigator.serial.requestPort()` to request a serial\n * port from the user. If the user selects a port, the function resolves with\n * the selected port. If an error occurs or the user cancels the selection, the\n * function logs the error and explicitly returns `undefined`.\n *\n * @returns {Promise<SerialPort | undefined>} A promise that resolves with the\n * selected `SerialPort` object if successful, or `undefined` if an error\n * occurs or no port is selected.\n */\nconst selectPort = async () => {\n  try {\n    // Request a port from the user\n    const port = await navigator.serial.requestPort();\n    return port; // Return the selected port\n  } catch (err) {\n    console.log(\"Error selecting port:\", err);\n    return undefined; // Explicitly return undefined on error\n  }\n};\n\n/**\n * Asynchronously connects to a given serial port and updates the state object.\n *\n * This function opens the specified serial port with the baud rate provided in\n * the state object. It sets up the necessary streams for reading and writing\n * data, stores the connection details, and initiates data reading from the port.\n * If the connection is successful, the state is updated accordingly.\n *\n * @async\n * @function connectToPort\n * @param {SerialPort} thePort - The serial port to connect to.\n * @param {Object} theState - The state object containing configuration and\n *                            where connection details will be stored.\n * @returns {Promise<boolean>} - Resolves to `true` if connection is successful,\n *                               otherwise `false`.\n *\n * @throws Will throw an error if the connection fails.\n */\nconst connectToPort = async (thePort, theState) => {\n  if (!thePort) {\n    console.log(\"No port provided.\");\n    return false;\n  }\n\n  try {\n    // Open the port with the given baud rate\n    await thePort.open({ baudRate: theState.baudRate });\n\n    // Set up text decoding for the readable stream\n    const decoder = new TextDecoderStream();\n    const inputDone = thePort.readable.pipeTo(decoder.writable);\n\n    // Retrieve reader and writer\n    const reader = decoder.readable.getReader();\n    const writer = thePort.writable.getWriter();\n\n    // Store the connected port and streams\n    theState.connectedPorts.push({ thePort, reader, writer });\n\n    // Log successful connection\n    console.log(\"Serial communication established with\", thePort.getInfo());\n\n    // Update the state\n    updateState(theState, {\n      connected: true,\n      port: thePort,\n      reader,\n      writer,\n      io: true, // @TODO: Decide if io is redundant\n    });\n\n    // Start reading from the port\n    await readFromPort(theState);\n\n    return true; // Indicate success\n  } catch (err) {\n    console.log(\"Error connecting to port:\", err);\n    cleanupResources(thePort, theState).then(() =>\n      console.log(\"Resources cleaned up.\")\n    ).catch(console.error);\n  }\n  return false;\n};\n\n/**\n * Reads data from the connected serial port in an asynchronous loop.\n *\n * Continuously reads incoming data from the port while the connection\n * remains active (`theState.connected`). Passes the data to a handler\n * function for processing. If an error occurs during reading, logs\n * the error and throws it for upstream handling. Ensures resources\n * like the reader and port are cleaned up when the reading stops or\n * an error occurs.\n *\n * @param {Object} theState - The application state object containing:\n *  - `connected` (boolean): Whether the port is connected.\n *  - `reader` (ReadableStreamDefaultReader): The port's reader for incoming data.\n *  - `port` (SerialPort): The connected serial port.\n *\n * @throws {Error} Re-throws any error encountered during reading.\n */\nconst readFromPort = async (theState) => {\n  try {\n    while (theState.connected) {\n      const { value, done } = await theState.reader.read();\n      if (done) break;\n      if (value) handleIncomingData(value, theState);\n    }\n  } catch (err) {\n    console.log(\"Error during read:\", err);\n    throw err;\n  } finally {\n    cleanupResources(theState.port, theState).then(() =>\n      console.log(\"Resources cleaned up.\")\n    ).catch(console.error);\n  }\n};\n\n/**\n * Cleans up serial port resources by canceling and releasing reader\n * and writer locks. Ensures proper closure of streams to prevent\n * resource leaks.\n *\n * @param {SerialPort} thePort - The serial port to be cleaned up (optional).\n * @param {Object} theState - The application state containing reader and writer.\n * @returns {Promise<void>} Resolves when cleanup is complete.\n */\nconst cleanupResources = async (thePort, theState) => {\n  // @TODO cleanup theState\n\n  try {\n    if (theState.reader) {\n      await theState.reader.cancel();\n      theState.reader.releaseLock();\n    }\n    if (theState.writer) {\n      await theState.writer.close();\n      theState.writer.releaseLock();\n    }\n  } catch (err) {\n    console.log(\"Error during cleanup:\", err);\n  }\n};\n","import {\n  checkPortConnectionFor,\n  getAvailablePorts,\n  reconnectToPreviouslyGrantedPorts,\n} from \"./rxtx.serial.port\";\n\n\n/**\n * Initializes the rxtx extension by checking available serial ports and managing\n * connection states. If no ports are detected, it adds a \"Connect\" button\n * to prompt the user for manual port selection. If ports are available, it\n * attempts to reconnect to previously granted ports.\n *\n * @async\n * @function startRxtxWith\n * @param {Object} theState - The application state object that holds serial\n *                            connection information and configurations.\n * @returns {Object} Updated state object after processing available ports.\n *\n */\n\nexport const startRxtxWith = async (theState) => {\n  const availablePorts = await getAvailablePorts();\n  // @TODO update state before returning\n  switch (availablePorts.length) {\n    case 0:\n      console.log(\"No previously granted ports detected, add connect button.\");\n      await addConnectButton(theState);\n      break;\n    default:\n      console.log(\"Previously granted ports detected, wait to reconnect ..\");\n      try {\n        await reconnectToPreviouslyGrantedPorts(theState);\n      } catch (err) {\n        console.log(\"couldn't reconnect to previously granted port(s).\");\n        await addConnectButton(theState);\n      }\n      break;\n  }\n  return theState;\n};\n\n/**\n * Adds a \"connect\" button to the interface for establishing a serial connection.\n *\n * The button is styled and positioned on the screen. When pressed, it attempts\n * to connect to a serial port using the provided state. If the connection fails,\n * the button is re-added for retrying. The button changes color on hover to\n * provide feedback to the user.\n *\n * @param {Object} theState - An object representing the current application state.\n *                            Includes configuration and callbacks for connection.\n *\n * Usage:\n * Call this function to display a \"connect\" button on the interface, allowing\n * users to establish a connection.\n */\n\nconst addConnectButton = async (theState) => {\n  // @TODO check if button already exists to avoid more \n  // than 1 instances at the same time\n  const button = createButton(\"connect\");\n  button.position(20, 20);\n  button.style(`\n    background: #03a1ff;\n    color: #fff;\n    font-size: 16px;\n    margin: auto;\n    border: 0;\n    padding: 8px 32px;\n    border-radius: 32px;\n    transition: background 0.3s;\n  `);\n\n  button.mouseOver(() => button.style(\"background: #06b004;\"));\n  button.mouseOut(() => button.style(\"background: #03a1ff;\"));\n\n  button.mousePressed(async () => {\n    theState.fn = (val) => {\n      // console.log(\"debug: \" + val);\n    };\n    button.remove();\n    try {\n      const isConnected = await checkPortConnectionFor(theState);\n      if (!isConnected) addConnectButton(theState);\n    } catch (err) {\n      console.log(err);\n    }\n  });\n};\n","/**\n * Toggles the application to enter fullscreen mode.\n *\n * This function checks if the application is not currently in fullscreen\n * mode using the `fullscreen()` function. If not in fullscreen, it switches\n * the application to fullscreen mode by setting `fullscreen(true)`.\n *\n * Note:\n * - This function assumes the presence of the `fullscreen()` utility, \n *   provided by p5.js.\n */\nexport const enterFullscreen = () => {\n  var fs = fullscreen();\n  if (!fs) {\n    fullscreen(true);\n  }\n};\n\n/**\n * Prevents touch move events on the document.\n *\n * This function disables the default behavior of touch move events,\n * such as scrolling or panning, when a user drags their finger across\n * the screen. Useful for applications where touch gestures should be\n * intercepted or restricted.\n *\n * @param {TouchEvent} event - The touch event triggered by a user's interaction.\n */\ndocument.ontouchmove = (event) => {\n  event.preventDefault();\n};","import { enterFullscreen } from \"./rxtx.window\";\nimport { getFormattedTimeStamp } from \"./rxtx.processing\";\n\n/**\n * Handles keypress events and updates the application state based on the\n * pressed key. Supports toggling debug modes, entering fullscreen,\n * and saving a canvas image. Checks for allowed keys and ensures state\n * consistency during keypress handling.\n * \n * Mapped keys can be dis/enabled with the mappedKeys option\n * @see initWith - Initializes the state with default, user-defined, settings\n *\n * @param {Object} theState - The current application state. Includes:\n *   - {boolean} isKeyPressed - Tracks whether a key is currently pressed.\n *   - {Object} debug - Manages debug settings:\n *       - {boolean} show - Toggles debug display.\n *       - {boolean} print - Toggles debug print mode.\n *   - {Array<string>} mappedKeys - Allowed keys for handling.\n *   - {Object} image - Contains image properties:\n *       - {string} format - File format for saved images.\n *       - {string} label - Prefix label for saved images.\n * \n */\nexport const keyPressed = (theState) => {\n  if (isKeyPressed === true) {\n    if (theState.isKeyPressed === false) {\n      theState.isKeyPressed = true;\n      if (!theState.mappedKeys.includes(key)) {\n        return;\n      }\n      switch (key) {\n        case \"d\":\n          theState.debug.show = !theState.debug.show;\n          break;\n        case \"f\":\n          enterFullscreen();\n          break;\n        case \"p\":\n          theState.debug.print = !theState.debug.print;\n          break;\n        case \"s\":\n          const l = theState.image.label;\n          const t = getFormattedTimeStamp();\n          const ext = theState.image.format;\n          const label = `${l}_${t}.${ext}`;\n          console.log(`saving image ${label}`);\n          saveCanvas(label, theState.image.format);\n          break;\n      }\n    }\n  } else {\n    theState.isKeyPressed = false;\n  }\n};\n","/**\n * Displays debugging information for the RXTX state.\n *\n * This function logs and visualizes the debug data stored in the `theState`\n * object. It first checks whether debugging options are enabled (`print` and\n * `show`) and whether valid data is available. If data is present and the\n * `show` option is enabled, a graphical layer is created or updated to display\n * the data as a list of visualized values on the canvas.\n *\n * The debug output includes:\n * - Text logging of debug data if `print` is enabled.\n * - A graphical representation of values, showing constrained bars and\n *   corresponding numeric labels.\n * - Integration with WebGL mode by offsetting the canvas transformation.\n *\n * @param {Object} theState - The state object containing debug information.\n */\nexport const showRxtxDebug = (theState) => {\n  if (theState.debug.print) {\n    if (theState.debug.data.value == undefined) {\n      console.log(\"debug.print, no data present yet.\");\n    } else {\n      console.log(theState.debug.data.value);\n    }\n  }\n  if (!theState.debug.show || !theState.debug.data.value) return;\n\n  const isWEBGL = drawingContext instanceof WebGLRenderingContext;\n\n  const v = theState.debug.data.value;\n  const id = theState.debug.data.id;\n  const label = `Device ${id}`;\n  const spacing = 20;\n  const header = 40;\n  const footer = 20;\n  const h = header + v.length * spacing + footer;\n  const w = 400;\n  if (!theState.debug.layer) {\n    theState.debug.layer = createGraphics(w, h);\n    theState.debug.layer.clear();\n  }\n  const l = theState.debug.layer;\n  l.clear();\n  l.noStroke();\n  l.fill(0, 40);\n  l.rect(0, 0, w, h, 16);\n  l.push();\n  l.translate(20, 20);\n  l.fill(255);\n  l.text(label, 0, 0);\n  l.translate(0, 20);\n  v.forEach((v, i) => {\n    let v0 = constrain(v, 0, 1);\n    l.push();\n    l.translate(0, i * 20);\n    l.fill(255, 40);\n    l.rect(0, 0, 300, 10, 4);\n    l.fill(255, 200);\n    l.rect(0, 2, v0 * 300, 8, 4);\n    l.fill(255);\n    l.text(v0.toFixed(2), 320, 10);\n    l.pop();\n  });\n  l.pop();\n\n  push();\n  if (isWEBGL) {\n    translate(-width / 2, -height / 2);\n  }\n  translate(20, 20);\n  image(theState.debug.layer, 0, 0);\n  pop();\n};\n\nexport const log = (...args) => {\n  let msg = ``;\n  args.forEach((el) => {\n    if (el instanceof Object) {\n      msg += `\\n${JSON.stringify(el, null, 2)}`;\n    } else {\n      msg += el;\n    }\n  });\n  console.log(\"rxtx debug : \", msg);\n};\n","import { deepMerge, updateState } from \"./rxtx.processing\";\nimport { startRxtxWith } from \"./rxtx.serial\";\nimport { keyPressed } from \"./rxtx.keyboard\";\nimport { showRxtxDebug } from \"./rxtx.debug\";\n\n/**\n * Initializes the application state with default, user-defined, and internal\n * settings. Merges these settings into `theState` and starts the rxtx process.\n *\n * @param {Object} theApp - The application instance (sketch or object), expected to\n *                          provide properties such as `rxtxEvent` for handling events.\n * @param {Object} theArgs - User-defined settings that override default values.\n *                           Example properties include:\n *                           - baudRate: Communication speed (default: 57600).\n *                           - id: Identifier for the state (default: -1).\n *                           - value: Array of values (default: []).\n *                           - debug: Debugging options { print: false, show: false }.\n * @param {Object} theState - The state object to be initialized with the merged\n *                            settings, including default, user-defined, and\n *                            internal configurations.\n */\nexport const initWith = (theApp, theArgs, theState) => {\n  const defaults = {\n    baudRate: 57600,\n    id: -1,\n    value: [],\n    fn: (ev) => {},\n    image: {\n      label: \"rxtx\",\n      format: \"jpg\",\n    },\n    mappedKeys: [\"d\",\"f\",\"p\",\"s\"],\n    debug: { print: false, show: false },\n  };\n\n  const internal = {\n    debug: { data: {} },\n    connected: false,\n    io: null,\n    isKeyPressed: false,\n    rxtxEvent: theApp.rxtxEvent || ((ev) => {}),\n    readBuffer: \"\",\n    connectedPorts: [],\n  };\n\n  updateState(theState, deepMerge(deepMerge(defaults, theArgs), internal));\n  startRxtxWith(theState);\n};\n\n/**\n * Performs an environment check for the p5.js instance and registers \n * custom behaviors for the window resize and specific \"post\" methods. \n * If p5.js is not found in the global scope, an error is logged.\n * \n * @param {object} theInstance - The global object to check for p5.js.\n * @param {object} theState - The application state object used for \n *                            handling key press and debugging behaviors.\n * \n * - Registers a `windowResized` function to resize the canvas dynamically.\n * - Registers \"post\" methods for handling key presses and debugging.\n * - Logs an error if p5.js is not available in the environment.\n * \n */\nexport const environmentCheck = (theInstance, theState) => {\n  (function (global) {\n    if (global.p5) {\n      global.p5.prototype.windowResized = () => {\n        resizeCanvas(windowWidth, windowHeight);\n      };\n\n      global.p5.prototype.registerMethod(\"post\", () => keyPressed(theState));\n      global.p5.prototype.registerMethod(\"post\", () => showRxtxDebug(theState));\n    } else {\n      console.error(\n        \"p5.js not found. Please include p5.js before this library.\",\n      );\n    }\n  })(theInstance);\n};\n","import { environmentCheck, initWith } from \"./rxtx.init\";\n\nconst state = {};\n\n/**\n * Initializes the rxtx connection with the specified app and options.\n *\n * This function sets up the rxtx extension for communication using the provided\n * p5.js sketch and configuration options. It should be called from the\n * `setup` function of your sketch. The configuration options allow for\n * customization of the baud rate, debugging behavior, and other settings.\n *\n * @param {object} theApp - The p5.js sketch instance (`this` from the sketch).\n * @param {object} [theArgs={}] - Configuration options for the connection.\n *\n * @example\n * // Call this function in your p5.js setup function:\n * let options = {\n *   baudRate: 57600,\n *   debug: { print: false, show: false },\n * };\n * rxtx.connect(this, options);\n *\n * @public\n */\nexport const connect = async (theApp, theArgs = {}) => {\n  initWith(theApp, theArgs, state);\n};\n\n/**\n * Checks if values are available in the RXTX state.\n *\n * This function verifies if the `value` field in the RXTX state is defined.\n * Returns `true` if values are available, otherwise `false`. It is designed\n * to be called frequently, such as within a p5.js `draw` function.\n *\n * Usage Example:\n * function draw() {\n *   background(220);\n *\n *   if (rxtx.isValuesAvailable()) {\n *     if (rxtx.getValueAt(0) === 1) {\n *       background(0);\n *     }\n *   }\n *   ...etc\n * }\n *\n * @returns {boolean} `true` if values are available, `false` otherwise.\n * @public\n */\nexport const isValuesAvailable = () => {\n  return state.debug.data.value == undefined ? false : true;\n};\n\nexport const isConnectionEstablished = () => {\n  return state.connected;\n};\n\nexport const isReadyToWrite = () => {\n  return state.io != null;\n};\n\n/**\n * Retrieves the value at the specified index from a list of values.\n *\n * If the index is out of bounds (greater than or equal to the length of\n * the values array), it returns -1. Otherwise, it returns the value\n * at the given index.\n *\n * @param {number} theIndex - The index of the value to retrieve.\n * @returns {*} The value at the specified index, or -1 if out of bounds.\n */\nexport const getValueAt = (theIndex) => {\n  const values = getValues();\n  return theIndex >= values.length ? -1 : values[theIndex];\n};\n\n/**\n * Retrieves the current values from the application state.\n *\n * This function returns the `value` property from the global `state` object.\n * If the `value` property is undefined or null, it defaults to an empty array.\n *\n * @returns {Array} - An array of current values or an empty array if no values\n *                    are set in the state.\n */\nexport const getValues = () => {\n  return state.value || [];\n};\n\n/**\n * Checks the runtime environment for necessary conditions and updates the\n * application state accordingly.\n *\n * @param {Window} window - The global window object, used for browser-related\n * checks.\n * @param {Object} state - The application state object to be updated based on\n * the environment check results.\n *\n * This function verifies if the runtime environment supports the required APIs\n * or features (e.g., Web Serial API) and updates the provided state object\n * with relevant flags or properties, enabling other parts of the application\n * to adapt to the current environment.\n *\n */\nenvironmentCheck(window, state);\n"],"names":["key","value","v"],"mappings":"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"}