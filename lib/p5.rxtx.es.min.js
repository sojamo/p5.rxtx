const e=async e=>{try{return JSON.parse(e)}catch(e){return{id:-1}}},t=(e,r)=>{for(const a in r)r[a]&&"object"==typeof r[a]&&!Array.isArray(r[a])?e[a]=t(e[a]||{},r[a]):e[a]=r[a];return e},r=(...e)=>{console.log("rxtx debug : ",e.join(" "))},a=async e=>{"serial"in navigator&&navigator.serial.getPorts().then((t=>{e.readBuffer="",0==t.length?n().then((t=>{s(t,e)})):s(t[0],e)}))},n=async()=>await navigator.serial.requestPort(),o=[],s=async(e,t)=>{console.log(e,t);try{await e.open({baudRate:t.baudRate});const a=new TextDecoderStream,n=e.readable.pipeTo(a.writable),s=a.readable.getReader(),i=e.writable.getWriter();return o.push({thePort:e,reader:s,writer:i}),r("Serial communication established with ",e.getInfo()),Object.assign(t,{connected:!0,port:e,reader:s,writer:i,io:!0}),d(t),{inputDone:n}}catch(e){throw r("Error connecting to port:",e),e}},i=async e=>{const t=await navigator.serial.getPorts();console.log("trying to reconnect to previous ports",t);for(const r of t)await s(r,e)},d=async t=>{for(;;){const{value:a,done:n}=await t.reader.read();if(a)if(a.includes("\n")){const r=split(a,"\n");t.readBuffer+=r[0],e(t.readBuffer).then((e=>{if(void 0!==e.value){t.value=e.value||[],t.id=e.id||-1,t.debug.data=t;const r={id:t.id,value:t.value};t.fn(r),t.rxtxEvent(r)}t.readBuffer=1!=r.length?r[1]:""}))}else t.readBuffer+=a;if(n){r("[readLoop] DONE",n),(void 0).reader.releaseLock();break}}};document.ontouchmove=e=>{e.preventDefault()};const l=e=>{if(!0===isKeyPressed){if(!1===e.isKeyPressed)switch(e.isKeyPressed=!0,key){case"f":fullscreen()||fullscreen(!0);break;case"p":e.debug.print=!e.debug.print;break;case"d":e.debug.show=!!e.debug.show;break;case"s":let t="";t=year()+nf(month(),2)+nf(day(),2),t+=nf(hour(),2)+nf(minute(),2)+nf(second(),2);let r="";r+=e.image.label,r+="_"+t,r+="."+e.image.format,log(`saving image ${r}`),saveCanvas(r,rxtxProps.image.format)}}else e.isKeyPressed=!1},u=(e,r,n)=>{const o={debug:{data:{}},connected:!1,io:null,isKeyPressed:!1,rxtxEvent:e.rxtxEvent||(e=>{}),readBuffer:""};Object.assign(n,t(t({baudRate:57600,id:-1,value:[],fn:e=>{},image:{label:"rxtx",format:"jpg"},debug:{print:!1,show:!1}},r),o)),(async e=>{try{return await i(e),e}catch(e){console.log("couldnt reconnect")}const t=createButton("connect");t.position(20,20),t.style("background:#03a1ff"),t.style("color:#fff"),t.style("font-size:16px"),t.style("margin:auto"),t.style("border:0"),t.style("padding:8px 32px"),t.style("border-radius:32px"),t.style("transition:background 0.3s"),t.mouseOver((()=>{t.style("background:#06b004")})),t.mouseOut((()=>{t.style("background:#03a1ff")})),t.mousePressed((()=>{e.fn=e=>{},a(e),t.remove()}))})(n)},c=async(e,t={})=>{u(e,t,h)},g=()=>null!=h.debug.data.value,f=()=>h.connected,p=()=>null!=h.io,b=e=>{const t=y();return e>=t.length?-1:t[e]},y=()=>h.value||[],h={};var v,w,x;v=window,w=h,(x=v).p5?(x.p5.prototype.windowResized=()=>{resizeCanvas(windowWidth,windowHeight)},x.p5.prototype.registerMethod("post",(()=>l(w))),x.p5.prototype.registerMethod("post",(()=>(e=>{if(e.debug.print&&(null==e.debug.data.value?r("debug.print, no data present yet."):r(e.debug.data.value)),!e.debug.show||!e.debug.data.value)return;const t=drawingContext instanceof WebGLRenderingContext;if(e.debug.layer){const t=e.debug.layer,r=e.debug.data.value,a=e.debug.data.id;t.clear(),t.noStroke(),t.fill(0,20),t.rect(0,0,400,200,16),t.push(),t.translate(20,20),t.fill(255),t.text(`Device ${a}`,0,0),t.translate(0,20),r.forEach(((e,r)=>{let a=constrain(e,0,1);t.push(),t.translate(0,20*r),t.fill(255,40),t.rect(0,0,300,10,4),t.fill(255,200),t.rect(0,2,300*a,8,4),t.fill(255),t.text(a.toFixed(2),320,10),t.pop()})),t.pop()}else e.debug.layer=createGraphics(400,200),e.debug.layer.clear();push(),t&&translate(-width/2,-height/2),translate(20,20),image(e.debug.layer,0,0),pop()})(w)))):console.error("p5.js not found. Please include p5.js before this library.");export{c as connect,b as getValueAt,y as getValues,f as isConnectionEstablished,p as isReadyToSend,g as isValuesAvailable};
//# sourceMappingURL=p5.rxtx.es.min.js.map
