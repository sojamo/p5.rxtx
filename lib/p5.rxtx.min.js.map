{"version":3,"file":"p5.rxtx.min.js","sources":["../src/utils/processing.js","../src/serial/data.js","../src/serial/port.js","../src/serial/setup.js","../src/ui/window.js","../src/ui/keyboard.js","../src/utils/debug.js","../src/main.js","../src/init.js"],"sourcesContent":["/**\n * Parses a JSON string and returns the resulting object.\n * If parsing fails, it returns a default object with an `id` of -1.\n *\n * @param {string} theString - The JSON string to be parsed.\n * @returns {Object} - The parsed JSON object, or a default object \n * if parsing fails.\n */\nexport const parseStringToJSON = async (theString) => {\n  try {\n    let json = JSON.parse(theString);\n    return json;\n  } catch (error) {\n    return { id: -1, value: [], type: \"error\" };\n  }\n};\n\n/**\n * Parses a string into an array of numbers or a single floating-point \n * number. If the string starts with '[', it is treated as a comma-separated \n * list of numbers. Otherwise, the string is parsed as a single float.\n *\n * @param {string} theData - The input string to be parsed.\n * @returns {number[]|number} - An array of numbers if the input represents a \n * list, or a single floating-point number if it does not.\n *\n * @example\n * parseStringToArray(\"[1, 2, 3]\"); // Returns [1, 2, 3]\n * parseStringToArray(\"42.5\");     // Returns 42.5\n */\nexport const parseStringToArray = (theData) => {\n  if (theData.charAt(0) == \"[\") {\n    let str0 = theData;\n    let str1 = str0.trim().replace(/[`\\[\\]\\\\\\/]/gi, \"\");\n    let arr0 = str1.split(\",\");\n    let arr1 = arr0.map(Number);\n    return arr1;\n  } else {\n    // @TODO do we want that here or should this default\n    // to an array with a single element.\n    return float(theData);\n  }\n};\n\n/**\n * Converts a string to an ArrayBuffer.\n *\n * This function takes a string and encodes it into an ArrayBuffer where each \n * character is represented by 2 bytes (UTF-16). The resulting ArrayBuffer can \n * be used for binary data manipulation.\n *\n * @param {string} theString - The input string to be converted.\n * @returns {ArrayBuffer} The resulting ArrayBuffer containing the encoded string.\n *\n * Example:\n * const buffer = str2ab(\"hello\");\n * console.log(buffer); // ArrayBuffer { byteLength: 10 }\n */\nexport const str2ab = (theString) => {\n  var buf = new ArrayBuffer(theString.length * 2); // 2 bytes for each char\n  var bufView = new Uint16Array(buf);\n  for (var i = 0, strLen = theString.length; i < strLen; i++) {\n    bufView[i] = theString.charCodeAt(i);\n  }\n  return buf;\n};\n\n/**\n * Recursively merges the properties of a source object into a target object.\n * If a property in the source is an object, it performs a deep merge. Arrays\n * are not deeply merged but overwritten. The target object is modified and\n * returned.\n *\n * @param {Object} target - The object to receive properties from the source.\n * @param {Object} source - The object whose properties are merged into the\n * target.\n * @returns {Object} - The modified target object after merging.\n *\n * @example\n * const target = { a: 1, b: { c: 2 } };\n * const source = { b: { d: 3 }, e: 4 };\n * const result = deepMerge(target, source);\n * console.log(result); // { a: 1, b: { c: 2, d: 3 }, e: 4 }\n */\nexport const deepMerge = (target, source) => {\n  for (const key in source) {\n    if (\n      source[key] && typeof source[key] === \"object\" &&\n      !Array.isArray(source[key])\n    ) {\n      target[key] = deepMerge(target[key] || {}, source[key]);\n    } else {\n      target[key] = source[key];\n    }\n  }\n  return target;\n};\n\n/**\n * Updates the given state object with new properties.\n * \n * This function merges the `updates` object into `theState` using\n * shallow copying. Existing properties in `theState` are overwritten \n * if they exist in `updates`, while new properties are added.\n * \n * @param {Object} theState - The state object to update.\n * @param {Object} updates - The object containing properties to merge\n *                           into the state.\n * \n * @example\n * const state = { a: 1, b: 2 };\n * updateState(state, { b: 3, c: 4 });\n * console.log(state); // { a: 1, b: 3, c: 4 }\n */\nexport const updateState = (theState, updates) => {\n  Object.assign(theState, updates);\n};\n\n/**\n * Generates a formatted timestamp string.\n *\n * This function constructs a timestamp in the format `YYYYMMDDHHmmSS` using\n * the current date and time. Each component (month, day, hour, minute, and\n * second) is zero-padded to ensure a consistent two-digit format.\n *\n * @returns {string} A timestamp string in the format `YYYYMMDDHHmmSS`.\n *\n * Example:\n *   If the current date and time is December 1, 2023, 15:05:09, the output\n *   will be: \"20231201150509\".\n */\nexport const getFormattedTimeStamp = () => {\n  let t = year() + nf(month(), 2) + nf(day(), 2);\n  t += nf(hour(), 2) + nf(minute(), 2) + nf(second(), 2);\n  return t;\n};\n","import { parseStringToJSON, updateState } from \"../utils/processing\";\n\nconst utf8EncodeText = new TextEncoder();\n\n/**\n * Sends data to the connected serial device via the Web Serial API.\n *\n * @async\n * @function rxtxSendTo\n * @param {Object} theState - The current application state, including the\n *                            serial port and writer.\n * @param {String} theString - The data to be sent to the serial device. This data\n *                      will be processed before being written.\n * @returns {Promise<boolean>} Returns true if the data was successfully sent,\n *                             or false if no port is available in the state.\n *\n * @example\n * const state = { port: somePort, writer: someWriter };\n * const success = await rxtxSendTo(state, \"{id:1, value:[1,2]}\");\n * console.log(success); // true if data was sent successfully\n */\nexport const rxtxSendTo = async (theState, theString) => {\n  if (!theState?.port) return false;\n  await theState.writer.write(checkRxtxData(theString));\n  return true;\n};\n\nconst checkRxtxData = (theData) => {\n  // see sketch https://editor.p5js.org/sojamo/sketches/yXZauy17X\n  // to type check, then operate on theData accordingly\n  // and return expected type so that it can be interpreted\n  // by the receiving end, the Arduino.\n  return utf8EncodeText.encode(theData);\n};\n\n/**\n * Processes incoming data from a serial stream, handling partial and complete\n * data chunks. Appends incomplete data to a buffer until a newline character\n * (`\\n`) is detected, at which point the buffer is parsed as JSON. Updates the\n * application state and triggers related events upon successful parsing.\n *\n * @param {string} value - Incoming data chunk from the serial stream.\n * @param {object} theState - Application state object that holds the buffer,\n *                            parsed data, and callback functions.\n *\n * @throws {Error} Logs an error if parsing the buffer as JSON fails.\n *\n * @example\n * handleIncomingData(\"[1,2,3]\\n\", theState);\n * // Parses \"[1,2,3]\" as JSON, updates the state, and triggers events.\n */\nexport const handleIncomingData = (value, theState) => {\n  if (!value.includes(\"\\n\")) {\n    theState.readBuffer += value;\n    return;\n  }\n  const [data, remainder] = value.split(\"\\n\");\n  theState.readBuffer += data;\n  parseStringToJSON(theState.readBuffer)\n    .then((parsedData) => {\n      if (parsedData.value !== undefined) {\n        \n        // @TODO fix this messy looking data transfer\n        const { id, value } = parsedData;\n        theState.debug.data = { value, id };\n        updateState(theState, {\n          value: value || [],\n          id: id || -1,\n          // debug: { data: theState }, // @TODO look into this assignment, overrides debug settings\n        });\n\n        theState.rxtxEvent({ \n          id: theState.id, \n          value: theState.value,\n          getValueAt: (theIndex) => theState.value[theIndex]\n        });\n      }\n      theState.readBuffer = remainder || \"\";\n    })\n    .catch((err) => console.log(\"Error parsing data:\", err));\n};\n","import { handleIncomingData } from \"./data\";\nimport { updateState } from \"../utils/processing\";\n\n/**\n * Retrieves all available serial ports that the user has\n * previously granted permission to access.\n *\n * This function utilizes the Web Serial API to list serial\n * ports that are currently available and for which the browser\n * has retained user permissions. If the Web Serial API is not\n * supported by the browser, an error is thrown.\n *\n * @async\n * @function getAvailablePorts\n * @throws {Error} If the Web Serial API is not supported by the browser.\n * @returns {Promise<SerialPort[]>} A promise that resolves to an array\n *                                  of `SerialPort` objects representing\n *                                  the available serial ports.\n */\nexport const getAvailablePorts = async () => {\n  if (!(\"serial\" in navigator)) {\n    throw new Error(\"Web Serial API not supported.\");\n  }\n  return await navigator.serial.getPorts();\n};\n\n/**\n * Attempts to reconnect to all previously granted serial ports.\n *\n * This function retrieves a list of previously granted serial ports using\n * `getAvailablePorts`, then iterates over each port to establish a connection\n * by calling `connectToPort`. The state (`theState`) is updated during each\n * connection attempt.\n *\n * @async\n * @param {Object} theState - The application state object used to manage\n *                            connections and serial port details.\n */\nexport const reconnectToPreviouslyGrantedPorts = async (theState) => {\n  const ports = await getAvailablePorts();\n  console.log(\"trying to reconnect to previous port(s)\", ports);\n\n  for (const port of ports) {\n    const connected = await connectToPort(port, theState);\n  }\n};\n\n/**\n * Checks and establishes a connection to a serial port for the given state.\n *\n * This function initializes the `readBuffer` in the provided state and attempts\n * to retrieve available serial ports. If no ports are available, it prompts\n * the user to select a port. Otherwise, it selects the first available port.\n * Once a port is identified, the function attempts to connect to it.\n *\n * @async\n * @function checkPortConnectionFor\n * @param {Object} theState - The application state object. It should contain\n *                            the required properties for managing the serial\n *                            connection and the read buffer.\n * @returns {Promise<boolean>} - Resolves to `true` if the connection is\n *                               successfully established; otherwise, `false`.\n */\nexport const checkPortConnectionFor = async (theState) => {\n  theState.readBuffer = \"\";\n\n  // Get available ports\n  const ports = await getAvailablePorts();\n\n  let port;\n  if (ports.length === 0) {\n    // Select a port if none are available\n    port = await selectPort();\n  } else {\n    // Select the first port available from the ports list\n    port = ports.length > 0 ? ports[0] : null;\n  }\n  return await connectToPort(port, theState);\n};\n\n/**\n * Prompts the user to select a serial port using the Web Serial API.\n *\n * This function uses `navigator.serial.requestPort()` to request a serial\n * port from the user. If the user selects a port, the function resolves with\n * the selected port. If an error occurs or the user cancels the selection, the\n * function logs the error and explicitly returns `undefined`.\n *\n * @returns {Promise<SerialPort | undefined>} A promise that resolves with the\n * selected `SerialPort` object if successful, or `undefined` if an error\n * occurs or no port is selected.\n */\nconst selectPort = async () => {\n  try {\n    // Request a port from the user\n    const port = await navigator.serial.requestPort();\n    return port; // Return the selected port\n  } catch (err) {\n    console.log(\"Error selecting port:\", err);\n    return undefined; // Explicitly return undefined on error\n  }\n};\n\n/**\n * Asynchronously connects to a given serial port and updates the state object.\n *\n * This function opens the specified serial port with the baud rate provided in\n * the state object. It sets up the necessary streams for reading and writing\n * data, stores the connection details, and initiates data reading from the port.\n * If the connection is successful, the state is updated accordingly.\n *\n * @async\n * @function connectToPort\n * @param {SerialPort} thePort - The serial port to connect to.\n * @param {Object} theState - The state object containing configuration and\n *                            where connection details will be stored.\n * @returns {Promise<boolean>} - Resolves to `true` if connection is successful,\n *                               otherwise `false`.\n *\n * @throws Will throw an error if the connection fails.\n */\nconst connectToPort = async (thePort, theState) => {\n  if (!thePort) {\n    console.log(\"No port provided.\");\n    return false;\n  }\n\n  try {\n    // Open the port with the given baud rate\n    await thePort.open({ baudRate: theState.baudRate });\n\n    // Set up text decoding for the readable stream\n    const decoder = new TextDecoderStream();\n    const inputDone = thePort.readable.pipeTo(decoder.writable);\n\n    // Retrieve reader and writer\n    const reader = decoder.readable.getReader();\n    const writer = thePort.writable.getWriter();\n\n    // Store the connected port and streams\n    theState.connectedPorts.push({ thePort, reader, writer });\n\n    // Log successful connection\n    console.log(\"Serial communication established with\", thePort.getInfo());\n\n    // Update the state\n    updateState(theState, {\n      connected: true,\n      port: thePort,\n      reader,\n      writer,\n      io: true, // @TODO: Decide if io is redundant\n    });\n    \n  } catch (err) {\n    console.log(\"Error connecting to port:\", err);\n\n    cleanupResources(thePort, theState).then(() =>\n      console.log(\"Resources cleaned up.\")\n    ).catch(console.error);\n\n    updateState(theState, {\n      connected: false,\n      port: thePort,\n      reader: null,\n      writer: null,\n      io: false, // @TODO: Decide if io is redundant\n    });\n    throw new Error(\"Failed to connect\");\n  }\n\n  await readFromPort(theState);\n  return false;\n};\n\n/**\n * Reads data from the connected serial port in an asynchronous loop.\n *\n * Continuously reads incoming data from the port while the connection\n * remains active (`theState.connected`). Passes the data to a handler\n * function for processing. If an error occurs during reading, logs\n * the error and throws it for upstream handling. Ensures resources\n * like the reader and port are cleaned up when the reading stops or\n * an error occurs.\n *\n * @param {Object} theState - The application state object containing:\n *  - `connected` (boolean): Whether the port is connected.\n *  - `reader` (ReadableStreamDefaultReader): The port's reader for incoming data.\n *  - `port` (SerialPort): The connected serial port.\n *\n * @throws {Error} Re-throws any error encountered during reading.\n */\nconst readFromPort = async (theState) => {\n  try {\n    while (theState.connected) {\n      const { value, done } = await theState.reader.read();\n      if (done) break;\n      if (value) handleIncomingData(value, theState);\n    }\n  } catch (err) {\n    console.log(\"Error during read:\", err);\n    throw err;\n  } finally {\n    cleanupResources(theState.port, theState).then(() =>\n      console.log(\"Resources cleaned up.\")\n    ).catch(console.error);\n  }\n};\n\n/**\n * Cleans up serial port resources by canceling and releasing reader\n * and writer locks. Ensures proper closure of streams to prevent\n * resource leaks.\n *\n * @param {SerialPort} thePort - The serial port to be cleaned up (optional).\n * @param {Object} theState - The application state containing reader and writer.\n * @returns {Promise<void>} Resolves when cleanup is complete.\n */\nconst cleanupResources = async (thePort, theState) => {\n  // @TODO cleanup theState\n\n  try {\n    if (theState.reader) {\n      await theState.reader.cancel();\n      theState.reader.releaseLock();\n    }\n    if (theState.writer) {\n      await theState.writer.close();\n      theState.writer.releaseLock();\n    }\n  } catch (err) {\n    console.log(\"Error during cleanup:\", err);\n  }\n};\n","import {\n  checkPortConnectionFor,\n  getAvailablePorts,\n  reconnectToPreviouslyGrantedPorts,\n} from \"./port\";\n\n/**\n * Initializes the rxtx extension by checking available serial ports and managing\n * connection states. If no ports are detected, it adds a \"Connect\" button\n * to prompt the user for manual port selection. If ports are available, it\n * attempts to reconnect to previously granted ports.\n *\n * @async\n * @function startRxtxWith\n * @param {Object} theState - The application state object that holds serial\n *                            connection information and configurations.\n * @returns {Object} Updated state object after processing available ports.\n */\n\nexport const startRxtxWith = async (theState) => {\n  const availablePorts = await getAvailablePorts();\n  // @TODO update state before returning\n  switch (availablePorts.length) {\n    case 0:\n      console.log(\"No previously granted ports detected, add connect button.\");\n      await addConnectButton(theState);\n      break;\n    default:\n      console.log(\"Previously granted ports detected, wait to reconnect ..\");\n      try {\n        await reconnectToPreviouslyGrantedPorts(theState);\n      } catch (err) {\n        console.log(\"couldn't reconnect to previously granted port(s).\");\n        await addConnectButton(theState, false);\n      }\n      break;\n  }\n  return theState;\n};\n\n/**\n * Adds a \"connect\" button to the interface for establishing a serial connection.\n *\n * The button is styled and positioned on the screen. When pressed, it attempts\n * to connect to a serial port using the provided state. If the connection fails,\n * the button is re-added for retrying. The button changes color on hover to\n * provide feedback to the user.\n *\n * @param {Object} theState - An object representing the current application state.\n *                            Includes configuration and callbacks for connection.\n *\n * Usage:\n * Call this function to display a \"connect\" button on the interface, allowing\n * users to establish a connection.\n */\n\nconst addConnectButton = async (theState, available = true) => {\n  // @TODO check if button already exists to avoid more\n  // than 1 instances at the same time\n  const label = available ? \"connect\" : \"unavailable\";\n  const col = available ? [\"#03a1ff\", \"#06b004\"] : [\"#ffa103\", \"#666666\"];\n  const button = createButton(label);\n  button.position(20, 20);\n  button.style(`\n    background: ${col[0]};\n    color: #fff;\n    font-size: 16px;\n    margin: auto;\n    border: 0;\n    padding: 8px 32px;\n    border-radius: 32px;\n    transition: background 0.3s;\n  `);\n\n  button.mouseOver(() => button.style(`background: ${col[1]};`));\n  button.mouseOut(() => button.style(`background: ${col[0]};`));\n\n  button.mousePressed(async () => {\n    \n    // remove the button before checkPortConnectionFor\n    // in the next step goes into while-loop mode\n    button.remove();\n    try {\n      // we have a connection\n      await checkPortConnectionFor(theState);\n    } catch (err) {\n      // we can't connect\n      console.log(`port is busy, ${err.message}`);\n      addConnectButton(theState, false); \n    }\n  });\n};\n","/**\n * Toggles the application to enter fullscreen mode.\n *\n * This function checks if the application is not currently in fullscreen\n * mode using the `fullscreen()` function. If not in fullscreen, it switches\n * the application to fullscreen mode by setting `fullscreen(true)`.\n *\n * Note:\n * - This function assumes the presence of the `fullscreen()` utility, \n *   provided by p5.js.\n */\nexport const enterFullscreen = () => {\n  var fs = fullscreen();\n  if (!fs) {\n    fullscreen(true);\n  }\n};\n\n/**\n * Prevents touch move events on the document.\n *\n * This function disables the default behavior of touch move events,\n * such as scrolling or panning, when a user drags their finger across\n * the screen. Useful for applications where touch gestures should be\n * intercepted or restricted.\n *\n * @param {TouchEvent} event - The touch event triggered by a user's interaction.\n */\ndocument.ontouchmove = (event) => {\n  event.preventDefault();\n};","import { enterFullscreen } from \"./window\";\nimport { getFormattedTimeStamp } from \"../utils/processing\";\n\n// @NOTE: Application version - injected from package.json during \n// production build, defaults to 'dev-version' during development\n// handled by vite plugin vite.plugin.version.js\nconst VERSION = /* @INJECT_VERSION */ || 'dev-version';\n\n/**\n * Handles keypress events and updates the application state based on the\n * pressed key. Supports toggling debug modes, entering fullscreen,\n * and saving a canvas image. Checks for allowed keys and ensures state\n * consistency during keypress handling.\n * \n * Mapped keys can be dis/enabled with the mappedKeys option\n * @see initWith - Initializes the state with default, user-defined, settings\n *\n * @param {Object} theState - The current application state. Includes:\n *   - {boolean} isKeyPressed - Tracks whether a key is currently pressed.\n *   - {Object} debug - Manages debug settings:\n *       - {boolean} show - Toggles debug display.\n *       - {boolean} print - Toggles debug print mode.\n *   - {Array<string>} mappedKeys - Allowed keys for handling.\n *   - {Object} image - Contains image properties:\n *       - {string} format - File format for saved images.\n *       - {string} label - Prefix label for saved images.\n * \n */\nexport const keyPressed = (theState) => {\n  if (isKeyPressed === true) {\n    if (theState.isKeyPressed === false) {\n      theState.isKeyPressed = true;\n      if (!theState.mappedKeys.includes(key)) {\n        return;\n      }\n      // @NOTE: to add a new mapped key, you need \n      // to add that key to the mappedKeys array (init.js)\n      switch (key) {\n        case \"d\":\n          theState.debug.show = !theState.debug.show;\n          break;\n        case \"f\":\n          enterFullscreen();\n          break;\n        case \"p\":\n          theState.debug.print = !theState.debug.print;\n          break;\n        case \"s\":\n          const l = theState.image.label;\n          const t = getFormattedTimeStamp();\n          const ext = theState.image.format;\n          const label = `${l}_${t}.${ext}`;\n          console.log(`saving image ${label}`);\n          saveCanvas(label, theState.image.format);\n          break;\n        case \"v\":\n          console.log(`p5.rxtx ${VERSION} by sojamo`);\n          break;\n      }\n    }\n  } else {\n    theState.isKeyPressed = false;\n  }\n};\n","/**\n * Main debug information display handler for rxtx state\n * @param {Object} theState - The state object containing debug information\n */\nexport const showRxtxDebug = (theState) => {\n  if (theState.debug === undefined) return;\n\n  handleDebugPrinting(theState);\n  if (!theState.debug.show || !theState.debug.data.value) return;\n\n  const dimensions = calculateDebugDimensions(theState.debug.data.value.length);\n  updateRanges(theState);\n\n  const layer = createOrUpdateDebugLayer(theState, dimensions);\n  drawDebug(theState, layer, dimensions);\n};\n\n/**\n * Handles console logging of debug data\n * @param {Object} theState - The state object\n */\nconst handleDebugPrinting = (theState) => {\n  if (!theState.debug.print) return;\n\n  if (theState.debug.data.value == undefined) {\n    console.log(\"debug.print, no data present yet.\");\n  } else {\n    console.log(theState.debug.data.value);\n  }\n};\n\n/**\n * Calculates dimensions for debug visualization\n * @param {number} theValueCount - Number of values to display\n * @returns {Object} Width, height, and layout parameters\n */\nconst calculateDebugDimensions = (theValueCount) => {\n  const spacing = 20;\n  const header = 40;\n  const footer = 20;\n  return {\n    width: 400,\n    height: header + theValueCount * spacing + footer,\n    spacing,\n    header,\n    footer,\n    barLength: 300,\n  };\n};\n\n/**\n * Updates value ranges in the state\n * @param {Object} theState - The state object\n */\nconst updateRanges = (theState) => {\n  const values = theState.debug.data.value;\n  const r0 = theState.range || [];\n  theState.range = updateRangeFor(values, r0);\n\n  values.forEach((v0, i) => {\n    theState.range[i].min = v0 < theState.range[i].min\n      ? v0\n      : theState.range[i].min;\n    theState.range[i].max = v0 > theState.range[i].max\n      ? v0\n      : theState.range[i].max;\n  });\n};\n\n/**\n * Creates or updates the graphics layer for debug visualization\n * @param {Object} theState - The state object\n * @param {Object} theDimensions - Layout dimensions\n * @returns {Object} Graphics layer\n */\nconst createOrUpdateDebugLayer = (theState, theDimensions) => {\n  if (!theState.debug.layer) {\n    theState.debug.layer = createGraphics(\n      theDimensions.width,\n      theDimensions.height,\n    );\n    theState.debug.layer.clear();\n  }\n  return theState.debug.layer;\n};\n\n/**\n * Draws the debug visualization\n * @param {Object} theState - The state object\n * @param {Object} theLayer - Graphics layer to draw on\n * @param {Object} theDimensions - Layout dimensions\n */\nconst drawDebug = (theState, theLayer, theDimensions) => {\n  drawBackground(theLayer, theDimensions);\n  drawHeader(theLayer, theState.debug.data.id);\n  drawValueBars(\n    theLayer,\n    theState.debug.data.value,\n    theState.range,\n    theDimensions,\n  );\n  renderFinalOutput(theLayer, isWebGLContext());\n};\n\n/**\n * Draws the background for debug visualization\n * @param {Object} theLayer - Graphics layer to draw on\n * @param {Object} theDimensions - Layout dimensions\n */\nconst drawBackground = (theLayer, theDimensions) => {\n  theLayer.clear();\n  theLayer.noStroke();\n  theLayer.fill(0, 40);\n  theLayer.rect(0, 0, theDimensions.width, theDimensions.height, 16);\n};\n\n/**\n * Draws the header with device ID\n * @param {Object} theLayer - Graphics layer to draw on\n * @param {string} theDeviceId - Device identifier\n */\nconst drawHeader = (theLayer, theDeviceId) => {\n  theLayer.push();\n  theLayer.translate(20, 20);\n  theLayer.fill(255);\n  theLayer.text(`Device ${theDeviceId}`, 0, 0);\n  theLayer.pop();\n};\n\n/**\n * Draws the value bars with their corresponding numbers\n * @param {Object} theLayer - Graphics layer to draw on\n * @param {Array} theValue - Array of values to visualize\n * @param {Array} theRanges - Array of min/max ranges for each value\n * @param {Object} theDimensions - Layout dimensions\n */\nconst drawValueBars = (theLayer, theValue, theRanges, theDimensions) => {\n  theLayer.push();\n  theLayer.translate(20, 40); // Offset after header\n\n  theValue.forEach((value, i) => {\n    const mappedValue = map(value, theRanges[i].min, theRanges[i].max, 0, 1);\n\n    theLayer.push();\n    theLayer.translate(0, i * theDimensions.spacing);\n\n    // Background bar\n    theLayer.fill(255, 40);\n    theLayer.rect(0, 0, theDimensions.barLength, 10, 4);\n\n    // Value bar\n    theLayer.fill(255, 200);\n    theLayer.rect(0, 2, mappedValue * theDimensions.barLength, 8, 4);\n\n    // Value text\n    theLayer.fill(255);\n    theLayer.text(value.toFixed(2), theDimensions.barLength + 20, 10);\n\n    theLayer.pop();\n  });\n\n  theLayer.pop();\n};\n\n/**\n * Renders the final output to the screen\n * @param {Object} theLayer - Graphics layer to render\n * @param {boolean} isWebGL - Whether we're in WebGL mode\n */\nconst renderFinalOutput = (theLayer, isWebGL) => {\n  push();\n\n  if (isWebGL) {\n    translate(-width / 2, -height / 2);\n  }\n\n  translate(20, 20);\n  image(theLayer, 0, 0);\n\n  pop();\n};\n\n/**\n * Checks if current context is WebGL\n * @returns {boolean} True if WebGL context\n */\nconst isWebGLContext = () => {\n  return drawingContext instanceof WebGLRenderingContext ||\n    drawingContext instanceof WebGL2RenderingContext;\n};\n\n/**\n * Synchronizes the range array size with the value array size.\n * Adds or removes elements from the range array to match the value array length.\n * New range elements are initialized with {min: 0, max: 1}.\n *\n * @param {Array} theValue - Source array to match length against\n * @param {Array} theRange - Target array to be resized\n * @returns {Array} Updated range array with matching length\n *\n * Example:\n * If theValue.length = 3 and theRange.length = 1\n * Result: theRange will be expanded to length 3 with new {min:0, max:1} elements\n */\nconst updateRangeFor = (theValue, theRange) => {\n  const valueDiff = theValue.length - theRange.length;\n\n  if (valueDiff > 0) {\n    // Add new elements to range\n    const newElements = Array(valueDiff).fill().map(() => ({ min: 0, max: 1 }));\n    theRange = [...theRange, ...newElements];\n  } else if (valueDiff < 0) {\n    // Remove excess elements from range\n    theRange = theRange.slice(0, value.length);\n  }\n  return theRange;\n};\n","import { environmentCheck, initWith } from \"./init\";\nimport { rxtxSendTo } from \"./serial/data\";\n\nconst state = {};\n\n/**\n * Initializes the rxtx connection with the specified app and options.\n *\n * This function sets up the rxtx extension for communication using the provided\n * p5.js sketch and configuration options. It should be called from the\n * `setup` function of your sketch. The configuration options allow for\n * customization of the baud rate, debugging behavior, and other settings.\n *\n * @param {object} theApp - The p5.js sketch instance (`this` from the sketch).\n * @param {object} [theArgs={}] - Configuration options for the connection.\n *\n * @example\n * // Call this function in your p5.js setup function:\n * let options = {\n *   baudRate: 57600,\n *   debug: { print: false, show: false },\n * };\n * rxtx.connect(this, options);\n *\n * @public\n */\nexport const connect = async (theApp, theArgs = {}) => {\n  initWith(theApp, theArgs, state);\n};\n\n/**\n * Checks if values are available in the rxtx state.\n *\n * This function verifies if the `value` field in the RXTX state is defined.\n * Returns `true` if values are available, otherwise `false`. It is designed\n * to be called frequently, such as within a p5.js `draw` function.\n *\n * Usage Example:\n * function draw() {\n *   background(220);\n *\n *   if (rxtx.isValuesAvailable()) {\n *     if (rxtx.getValueAt(0) === 1) {\n *       background(0);\n *     }\n *   }\n *   ...etc\n * }\n *\n * @returns {boolean} `true` if values are available, `false` otherwise.\n * @public\n */\nexport const isValuesAvailable = () => {\n  return state.debug.data.value == undefined ? false : true;\n};\n\nexport const isConnectionEstablished = () => {\n  return state.connected;\n};\n\nexport const isReadyToSend = () => {\n  return state.io != null;\n};\n\n/**\n * Retrieves the value at the specified index from a list of values.\n *\n * If the index is out of bounds (greater than or equal to the length of\n * the values array), it returns -1. Otherwise, it returns the value\n * at the given index.\n *\n * @param {number} theIndex - The index of the value to retrieve.\n * @returns {*} The value at the specified index, or -1 if out of bounds.\n */\nexport const getValueAt = (theIndex) => {\n  const values = getValues();\n  return theIndex >= values.length ? -1 : values[theIndex];\n};\n\n/**\n * Retrieves the current values from the application state.\n *\n * This function returns the `value` property from the global `state` object.\n * If the `value` property is undefined or null, it defaults to an empty array.\n *\n * @returns {Array} - An array of current values or an empty array if no values\n *                    are set in the state.\n */\nexport const getValues = () => {\n  return state.value || [];\n};\n\nexport const send = (theJSONformattedData) => {\n  const str = JSON.stringify(theJSONformattedData);\n  rxtxSendTo(state, str);\n};\n\n/**\n * Checks the runtime environment for necessary conditions\n * and updates the application state accordingly.\n *\n * @param {Window} window - The global window object, used\n * for browser-related checks.\n * @param {Object} state - The application state object to\n * be updated based on the environment check results.\n *\n * This function verifies if the runtime environment supports\n * the required APIs or features (e.g., Web Serial API) and updates\n * the provided state object with relevant flags or properties,\n * enabling other parts of the application to adapt to the\n * current environment.\n */\nenvironmentCheck(window, state);\n","import { deepMerge, updateState } from \"./utils/processing\";\nimport { startRxtxWith } from \"./serial/setup\";\nimport { keyPressed } from \"./ui/keyboard\";\nimport { showRxtxDebug } from \"./utils/debug\";\n\n/**\n * Initializes the application state with default, user-defined, and internal\n * settings. Merges these settings into `theState` and starts the rxtx process.\n *\n * @param {Object} theApp - The application instance (sketch or object), expected to\n *                          provide properties such as `rxtxEvent` for handling events.\n * @param {Object} theArgs - User-defined settings that override default values.\n *                           Example properties include:\n *                           - baudRate: Communication speed (default: 57600).\n *                           - id: Identifier for the state (default: -1).\n *                           - value: Array of values (default: []).\n *                           - debug: Debugging options { print: false, show: false }.\n * @param {Object} theState - The state object to be initialized with the merged\n *                            settings, including default, user-defined, and\n *                            internal configurations.\n */\nexport const initWith = (theApp, theArgs, theState) => {\n  const defaults = {\n    baudRate: 57600,\n    id: -1,\n    value: [],\n    range: [],\n    image: {\n      label: \"rxtx\",\n      format: \"jpg\",\n    },\n    mappedKeys: [\"d\", \"f\", \"p\", \"s\", \"v\"],\n    debug: { print: false, show: false },\n  };\n\n  const internal = {\n    debug: { data: {} },\n    connected: false,\n    io: null,\n    isKeyPressed: false,\n    rxtxEvent: theApp.rxtxEvent || ((ev) => {}),\n    readBuffer: \"\",\n    connectedPorts: [],\n  };\n\n  updateState(theState, deepMerge(deepMerge(defaults, theArgs), internal));\n  startRxtxWith(theState);\n};\n\n/**\n * Performs an environment check for the p5.js instance and registers\n * custom behaviors for the window resize and specific \"post\" methods.\n * If p5.js is not found in the global scope, an error is logged.\n *\n * @param {object} theInstance - The global object to check for p5.js.\n * @param {object} theState - The application state object used for\n *                            handling key press and debugging behaviors.\n *\n * - Registers a `windowResized` function to resize the canvas dynamically.\n * - Registers \"post\" methods for handling key presses and debugging.\n * - Logs an error if p5.js is not available in the environment.\n */\nexport const environmentCheck = (theInstance, theState) => {\n  (function (global) {\n    if (global.p5) {\n      global.p5.prototype.windowResized = () => {\n        resizeCanvas(windowWidth, windowHeight);\n      };\n\n      global.p5.prototype.registerMethod(\"post\", () => keyPressed(theState));\n      global.p5.prototype.registerMethod(\"post\", () => showRxtxDebug(theState));\n    } else {\n      console.error(\n        \"p5.js not found. Please include p5.js before this library.\",\n      );\n    }\n  })(theInstance);\n};\n"],"names":["deepMerge","target","source","key","Array","isArray","updateState","theState","updates","Object","assign","utf8EncodeText","TextEncoder","checkRxtxData","theData","encode","handleIncomingData","value","includes","readBuffer","data","remainder","split","async","theString","JSON","parse","error","id","type","parseStringToJSON","then","parsedData","debug","rxtxEvent","getValueAt","theIndex","catch","err","console","log","getAvailablePorts","navigator","Error","serial","getPorts","selectPort","requestPort","connectToPort","thePort","open","baudRate","decoder","TextDecoderStream","reader","readable","pipeTo","writable","getReader","writer","getWriter","connectedPorts","push","getInfo","connected","port","io","cleanupResources","readFromPort","done","read","cancel","releaseLock","close","startRxtxWith","length","addConnectButton","ports","reconnectToPreviouslyGrantedPorts","available","col","button","createButton","position","style","mouseOver","mouseOut","mousePressed","remove","checkPortConnectionFor","message","document","ontouchmove","event","preventDefault","keyPressed","isKeyPressed","mappedKeys","show","fullscreen","print","label","image","t","year","nf","month","day","hour","minute","second","getFormattedTimeStamp","format","saveCanvas","handleDebugPrinting","calculateDebugDimensions","theValueCount","width","height","spacing","header","footer","barLength","updateRanges","values","r0","range","updateRangeFor","forEach","v0","i","min","max","createOrUpdateDebugLayer","theDimensions","layer","createGraphics","clear","drawDebug","theLayer","drawBackground","drawHeader","drawValueBars","renderFinalOutput","isWebGLContext","noStroke","fill","rect","theDeviceId","translate","text","pop","theValue","theRanges","mappedValue","map","toFixed","isWebGL","drawingContext","WebGLRenderingContext","WebGL2RenderingContext","theRange","valueDiff","newElements","slice","state","getValues","theInstance","global","window","p5","prototype","windowResized","resizeCanvas","windowWidth","windowHeight","registerMethod","dimensions","showRxtxDebug","theApp","theArgs","internal","ev","initWith","theJSONformattedData","str","stringify","write","rxtxSendTo"],"mappings":"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"}