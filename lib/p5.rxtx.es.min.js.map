{"version":3,"file":"p5.rxtx.es.min.js","sources":["../src/utils/processing.js","../src/serial/data.js","../src/serial/port.js","../src/serial/setup.js","../src/ui/window.js","../src/ui/keyboard.js","../src/main.js","../src/init.js","../src/utils/debug.js"],"sourcesContent":["/**\n * Parses a JSON string and returns the resulting object.\n * If parsing fails, it returns a default object with an `id` of -1.\n *\n * @param {string} theString - The JSON string to be parsed.\n * @returns {Object} - The parsed JSON object, or a default object \n * if parsing fails.\n */\nexport const parseStringToJSON = async (theString) => {\n  try {\n    let json = JSON.parse(theString);\n    return json;\n  } catch (error) {\n    return { id: -1 };\n  }\n};\n\n/**\n * Parses a string into an array of numbers or a single floating-point \n * number. If the string starts with '[', it is treated as a comma-separated \n * list of numbers. Otherwise, the string is parsed as a single float.\n *\n * @param {string} theData - The input string to be parsed.\n * @returns {number[]|number} - An array of numbers if the input represents a \n * list, or a single floating-point number if it does not.\n *\n * @example\n * parseStringToArray(\"[1, 2, 3]\"); // Returns [1, 2, 3]\n * parseStringToArray(\"42.5\");     // Returns 42.5\n */\nexport const parseStringToArray = (theData) => {\n  if (theData.charAt(0) == \"[\") {\n    let str0 = theData;\n    let str1 = str0.trim().replace(/[`\\[\\]\\\\\\/]/gi, \"\");\n    let arr0 = str1.split(\",\");\n    let arr1 = arr0.map(Number);\n    return arr1;\n  } else {\n    // @TODO do we want that here or should this default\n    // to an array with a single element.\n    return float(theData);\n  }\n};\n\n/**\n * Converts a string to an ArrayBuffer.\n *\n * This function takes a string and encodes it into an ArrayBuffer where each \n * character is represented by 2 bytes (UTF-16). The resulting ArrayBuffer can \n * be used for binary data manipulation.\n *\n * @param {string} theString - The input string to be converted.\n * @returns {ArrayBuffer} The resulting ArrayBuffer containing the encoded string.\n *\n * Example:\n * const buffer = str2ab(\"hello\");\n * console.log(buffer); // ArrayBuffer { byteLength: 10 }\n */\nexport const str2ab = (theString) => {\n  var buf = new ArrayBuffer(theString.length * 2); // 2 bytes for each char\n  var bufView = new Uint16Array(buf);\n  for (var i = 0, strLen = theString.length; i < strLen; i++) {\n    bufView[i] = theString.charCodeAt(i);\n  }\n  return buf;\n};\n\n/**\n * Recursively merges the properties of a source object into a target object.\n * If a property in the source is an object, it performs a deep merge. Arrays\n * are not deeply merged but overwritten. The target object is modified and\n * returned.\n *\n * @param {Object} target - The object to receive properties from the source.\n * @param {Object} source - The object whose properties are merged into the\n * target.\n * @returns {Object} - The modified target object after merging.\n *\n * @example\n * const target = { a: 1, b: { c: 2 } };\n * const source = { b: { d: 3 }, e: 4 };\n * const result = deepMerge(target, source);\n * console.log(result); // { a: 1, b: { c: 2, d: 3 }, e: 4 }\n */\nexport const deepMerge = (target, source) => {\n  for (const key in source) {\n    if (\n      source[key] && typeof source[key] === \"object\" &&\n      !Array.isArray(source[key])\n    ) {\n      target[key] = deepMerge(target[key] || {}, source[key]);\n    } else {\n      target[key] = source[key];\n    }\n  }\n  return target;\n};\n\n/**\n * Updates the given state object with new properties.\n * \n * This function merges the `updates` object into `theState` using\n * shallow copying. Existing properties in `theState` are overwritten \n * if they exist in `updates`, while new properties are added.\n * \n * @param {Object} theState - The state object to update.\n * @param {Object} updates - The object containing properties to merge\n *                           into the state.\n * \n * @example\n * const state = { a: 1, b: 2 };\n * updateState(state, { b: 3, c: 4 });\n * console.log(state); // { a: 1, b: 3, c: 4 }\n */\nexport const updateState = (theState, updates) => {\n  Object.assign(theState, updates);\n};\n\n/**\n * Generates a formatted timestamp string.\n *\n * This function constructs a timestamp in the format `YYYYMMDDHHmmSS` using\n * the current date and time. Each component (month, day, hour, minute, and\n * second) is zero-padded to ensure a consistent two-digit format.\n *\n * @returns {string} A timestamp string in the format `YYYYMMDDHHmmSS`.\n *\n * Example:\n *   If the current date and time is December 1, 2023, 15:05:09, the output\n *   will be: \"20231201150509\".\n */\nexport const getFormattedTimeStamp = () => {\n  let t = year() + nf(month(), 2) + nf(day(), 2);\n  t += nf(hour(), 2) + nf(minute(), 2) + nf(second(), 2);\n  return t;\n};\n","import { parseStringToJSON, updateState } from \"../utils/processing\";\n\n/**\n * Sends data to the connected serial device via the Web Serial API.\n *\n * @async\n * @function rxtxWriteTo\n * @param {Object} theState - The current application state, including the\n *                            serial port and writer.\n * @param {*} theData - The data to be sent to the serial device. This data\n *                      will be processed before being written.\n * @returns {Promise<boolean>} Returns true if the data was successfully sent,\n *                             or false if no port is available in the state.\n *\n * @example\n * const state = { port: somePort, writer: someWriter };\n * const success = await rxtxWriteTo(state, \"Hello Device\");\n * console.log(success); // true if data was sent successfully\n */\nexport const rxtxWriteTo = async (theState, theData) => {\n  if (!theState?.port) return false;\n  await theState.writer.write(checkRxtxData(theData));\n  return true;\n};\n\nconst checkRxtxData = (theData) => {\n  // see sketch https://editor.p5js.org/sojamo/sketches/yXZauy17X\n  // to type check, then operate on theData accordingly\n  // and return expected type so that it can be interpreted\n  // by the receiving end, the Arduino.\n  return utf8EncodeText.encode(theData);\n};\n\n/**\n * Processes incoming data from a serial stream, handling partial and complete\n * data chunks. Appends incomplete data to a buffer until a newline character\n * (`\\n`) is detected, at which point the buffer is parsed as JSON. Updates the\n * application state and triggers related events upon successful parsing.\n *\n * @param {string} value - Incoming data chunk from the serial stream.\n * @param {object} theState - Application state object that holds the buffer,\n *                            parsed data, and callback functions.\n *\n * @throws {Error} Logs an error if parsing the buffer as JSON fails.\n *\n * @example\n * handleIncomingData(\"[1,2,3]\\n\", theState);\n * // Parses \"[1,2,3]\" as JSON, updates the state, and triggers events.\n */\nexport const handleIncomingData = (value, theState) => {\n  if (!value.includes(\"\\n\")) {\n    theState.readBuffer += value;\n    return;\n  }\n  const [data, remainder] = value.split(\"\\n\");\n  theState.readBuffer += data;\n  parseStringToJSON(theState.readBuffer)\n    .then((parsedData) => {\n      if (parsedData.value !== undefined) {\n        // @TODO fix this messy looking data transfer\n        const { id, value } = parsedData;\n        theState.debug.data = { value, id };\n        updateState(theState, {\n          value: value || [],\n          id: id || -1,\n          // debug: { data: theState }, // @TODO look into this assignment, overrides debug settings\n        });\n\n        theState.fn({ id: theState.id, value: theState.value });\n        theState.rxtxEvent({ id: theState.id, value: theState.value });\n      }\n      theState.readBuffer = remainder || \"\";\n    })\n    .catch((err) => console.log(\"Error parsing data:\", err));\n};\n","import { handleIncomingData } from \"./data\";\nimport { updateState } from \"../utils/processing\";\n\n/**\n * Retrieves all available serial ports that the user has\n * previously granted permission to access.\n *\n * This function utilizes the Web Serial API to list serial\n * ports that are currently available and for which the browser\n * has retained user permissions. If the Web Serial API is not\n * supported by the browser, an error is thrown.\n *\n * @async\n * @function getAvailablePorts\n * @throws {Error} If the Web Serial API is not supported by the browser.\n * @returns {Promise<SerialPort[]>} A promise that resolves to an array\n *                                  of `SerialPort` objects representing\n *                                  the available serial ports.\n */\nexport const getAvailablePorts = async () => {\n  if (!(\"serial\" in navigator)) {\n    throw new Error(\"Web Serial API not supported.\");\n  }\n  return await navigator.serial.getPorts();\n};\n\n/**\n * Attempts to reconnect to all previously granted serial ports.\n *\n * This function retrieves a list of previously granted serial ports using\n * `getAvailablePorts`, then iterates over each port to establish a connection\n * by calling `connectToPort`. The state (`theState`) is updated during each\n * connection attempt.\n *\n * @async\n * @param {Object} theState - The application state object used to manage\n *                            connections and serial port details.\n */\nexport const reconnectToPreviouslyGrantedPorts = async (theState) => {\n  const ports = await getAvailablePorts();\n  console.log(\"trying to reconnect to previous ports\", ports);\n  for (const port of ports) {\n    await connectToPort(port, theState);\n  }\n};\n\n/**\n * Checks and establishes a connection to a serial port for the given state.\n *\n * This function initializes the `readBuffer` in the provided state and attempts\n * to retrieve available serial ports. If no ports are available, it prompts\n * the user to select a port. Otherwise, it selects the first available port.\n * Once a port is identified, the function attempts to connect to it.\n *\n * @async\n * @function checkPortConnectionFor\n * @param {Object} theState - The application state object. It should contain\n *                            the required properties for managing the serial\n *                            connection and the read buffer.\n * @returns {Promise<boolean>} - Resolves to `true` if the connection is\n *                               successfully established; otherwise, `false`.\n */\nexport const checkPortConnectionFor = async (theState) => {\n  theState.readBuffer = \"\";\n\n  // Get available ports\n  const ports = await getAvailablePorts();\n\n  let port;\n  if (ports.length === 0) {\n    // Select a port if none are available\n    port = await selectPort();\n  } else {\n    // Select the first port available from the ports list\n    port = ports[0];\n  }\n  return await connectToPort(port, theState);\n};\n\n/**\n * Prompts the user to select a serial port using the Web Serial API.\n *\n * This function uses `navigator.serial.requestPort()` to request a serial\n * port from the user. If the user selects a port, the function resolves with\n * the selected port. If an error occurs or the user cancels the selection, the\n * function logs the error and explicitly returns `undefined`.\n *\n * @returns {Promise<SerialPort | undefined>} A promise that resolves with the\n * selected `SerialPort` object if successful, or `undefined` if an error\n * occurs or no port is selected.\n */\nconst selectPort = async () => {\n  try {\n    // Request a port from the user\n    const port = await navigator.serial.requestPort();\n    return port; // Return the selected port\n  } catch (err) {\n    console.log(\"Error selecting port:\", err);\n    return undefined; // Explicitly return undefined on error\n  }\n};\n\n/**\n * Asynchronously connects to a given serial port and updates the state object.\n *\n * This function opens the specified serial port with the baud rate provided in\n * the state object. It sets up the necessary streams for reading and writing\n * data, stores the connection details, and initiates data reading from the port.\n * If the connection is successful, the state is updated accordingly.\n *\n * @async\n * @function connectToPort\n * @param {SerialPort} thePort - The serial port to connect to.\n * @param {Object} theState - The state object containing configuration and\n *                            where connection details will be stored.\n * @returns {Promise<boolean>} - Resolves to `true` if connection is successful,\n *                               otherwise `false`.\n *\n * @throws Will throw an error if the connection fails.\n */\nconst connectToPort = async (thePort, theState) => {\n  if (!thePort) {\n    console.log(\"No port provided.\");\n    return false;\n  }\n\n  try {\n    // Open the port with the given baud rate\n    await thePort.open({ baudRate: theState.baudRate });\n\n    // Set up text decoding for the readable stream\n    const decoder = new TextDecoderStream();\n    const inputDone = thePort.readable.pipeTo(decoder.writable);\n\n    // Retrieve reader and writer\n    const reader = decoder.readable.getReader();\n    const writer = thePort.writable.getWriter();\n\n    // Store the connected port and streams\n    theState.connectedPorts.push({ thePort, reader, writer });\n\n    // Log successful connection\n    console.log(\"Serial communication established with\", thePort.getInfo());\n\n    // Update the state\n    updateState(theState, {\n      connected: true,\n      port: thePort,\n      reader,\n      writer,\n      io: true, // @TODO: Decide if io is redundant\n    });\n\n    // Start reading from the port\n    await readFromPort(theState);\n\n    return true; // Indicate success\n  } catch (err) {\n    console.log(\"Error connecting to port:\", err);\n    cleanupResources(thePort, theState).then(() =>\n      console.log(\"Resources cleaned up.\")\n    ).catch(console.error);\n  }\n  return false;\n};\n\n/**\n * Reads data from the connected serial port in an asynchronous loop.\n *\n * Continuously reads incoming data from the port while the connection\n * remains active (`theState.connected`). Passes the data to a handler\n * function for processing. If an error occurs during reading, logs\n * the error and throws it for upstream handling. Ensures resources\n * like the reader and port are cleaned up when the reading stops or\n * an error occurs.\n *\n * @param {Object} theState - The application state object containing:\n *  - `connected` (boolean): Whether the port is connected.\n *  - `reader` (ReadableStreamDefaultReader): The port's reader for incoming data.\n *  - `port` (SerialPort): The connected serial port.\n *\n * @throws {Error} Re-throws any error encountered during reading.\n */\nconst readFromPort = async (theState) => {\n  try {\n    while (theState.connected) {\n      const { value, done } = await theState.reader.read();\n      if (done) break;\n      if (value) handleIncomingData(value, theState);\n    }\n  } catch (err) {\n    console.log(\"Error during read:\", err);\n    throw err;\n  } finally {\n    cleanupResources(theState.port, theState).then(() =>\n      console.log(\"Resources cleaned up.\")\n    ).catch(console.error);\n  }\n};\n\n/**\n * Cleans up serial port resources by canceling and releasing reader\n * and writer locks. Ensures proper closure of streams to prevent\n * resource leaks.\n *\n * @param {SerialPort} thePort - The serial port to be cleaned up (optional).\n * @param {Object} theState - The application state containing reader and writer.\n * @returns {Promise<void>} Resolves when cleanup is complete.\n */\nconst cleanupResources = async (thePort, theState) => {\n  // @TODO cleanup theState\n\n  try {\n    if (theState.reader) {\n      await theState.reader.cancel();\n      theState.reader.releaseLock();\n    }\n    if (theState.writer) {\n      await theState.writer.close();\n      theState.writer.releaseLock();\n    }\n  } catch (err) {\n    console.log(\"Error during cleanup:\", err);\n  }\n};\n","import {\n  checkPortConnectionFor,\n  getAvailablePorts,\n  reconnectToPreviouslyGrantedPorts,\n} from \"./port\";\n\n\n/**\n * Initializes the rxtx extension by checking available serial ports and managing\n * connection states. If no ports are detected, it adds a \"Connect\" button\n * to prompt the user for manual port selection. If ports are available, it\n * attempts to reconnect to previously granted ports.\n *\n * @async\n * @function startRxtxWith\n * @param {Object} theState - The application state object that holds serial\n *                            connection information and configurations.\n * @returns {Object} Updated state object after processing available ports.\n *\n */\n\nexport const startRxtxWith = async (theState) => {\n  const availablePorts = await getAvailablePorts();\n  // @TODO update state before returning\n  switch (availablePorts.length) {\n    case 0:\n      console.log(\"No previously granted ports detected, add connect button.\");\n      await addConnectButton(theState);\n      break;\n    default:\n      console.log(\"Previously granted ports detected, wait to reconnect ..\");\n      try {\n        await reconnectToPreviouslyGrantedPorts(theState);\n      } catch (err) {\n        console.log(\"couldn't reconnect to previously granted port(s).\");\n        await addConnectButton(theState);\n      }\n      break;\n  }\n  return theState;\n};\n\n/**\n * Adds a \"connect\" button to the interface for establishing a serial connection.\n *\n * The button is styled and positioned on the screen. When pressed, it attempts\n * to connect to a serial port using the provided state. If the connection fails,\n * the button is re-added for retrying. The button changes color on hover to\n * provide feedback to the user.\n *\n * @param {Object} theState - An object representing the current application state.\n *                            Includes configuration and callbacks for connection.\n *\n * Usage:\n * Call this function to display a \"connect\" button on the interface, allowing\n * users to establish a connection.\n */\n\nconst addConnectButton = async (theState) => {\n  // @TODO check if button already exists to avoid more \n  // than 1 instances at the same time\n  const button = createButton(\"connect\");\n  button.position(20, 20);\n  button.style(`\n    background: #03a1ff;\n    color: #fff;\n    font-size: 16px;\n    margin: auto;\n    border: 0;\n    padding: 8px 32px;\n    border-radius: 32px;\n    transition: background 0.3s;\n  `);\n\n  button.mouseOver(() => button.style(\"background: #06b004;\"));\n  button.mouseOut(() => button.style(\"background: #03a1ff;\"));\n\n  button.mousePressed(async () => {\n    theState.fn = (val) => {\n      // console.log(\"debug: \" + val);\n    };\n    button.remove();\n    try {\n      const isConnected = await checkPortConnectionFor(theState);\n      if (!isConnected) addConnectButton(theState);\n    } catch (err) {\n      console.log(err);\n    }\n  });\n};\n","/**\n * Toggles the application to enter fullscreen mode.\n *\n * This function checks if the application is not currently in fullscreen\n * mode using the `fullscreen()` function. If not in fullscreen, it switches\n * the application to fullscreen mode by setting `fullscreen(true)`.\n *\n * Note:\n * - This function assumes the presence of the `fullscreen()` utility, \n *   provided by p5.js.\n */\nexport const enterFullscreen = () => {\n  var fs = fullscreen();\n  if (!fs) {\n    fullscreen(true);\n  }\n};\n\n/**\n * Prevents touch move events on the document.\n *\n * This function disables the default behavior of touch move events,\n * such as scrolling or panning, when a user drags their finger across\n * the screen. Useful for applications where touch gestures should be\n * intercepted or restricted.\n *\n * @param {TouchEvent} event - The touch event triggered by a user's interaction.\n */\ndocument.ontouchmove = (event) => {\n  event.preventDefault();\n};","import { enterFullscreen } from \"./window\";\nimport { getFormattedTimeStamp } from \"../utils/processing\";\n\n/**\n * Handles keypress events and updates the application state based on the\n * pressed key. Supports toggling debug modes, entering fullscreen,\n * and saving a canvas image. Checks for allowed keys and ensures state\n * consistency during keypress handling.\n * \n * Mapped keys can be dis/enabled with the mappedKeys option\n * @see initWith - Initializes the state with default, user-defined, settings\n *\n * @param {Object} theState - The current application state. Includes:\n *   - {boolean} isKeyPressed - Tracks whether a key is currently pressed.\n *   - {Object} debug - Manages debug settings:\n *       - {boolean} show - Toggles debug display.\n *       - {boolean} print - Toggles debug print mode.\n *   - {Array<string>} mappedKeys - Allowed keys for handling.\n *   - {Object} image - Contains image properties:\n *       - {string} format - File format for saved images.\n *       - {string} label - Prefix label for saved images.\n * \n */\nexport const keyPressed = (theState) => {\n  if (isKeyPressed === true) {\n    if (theState.isKeyPressed === false) {\n      theState.isKeyPressed = true;\n      if (!theState.mappedKeys.includes(key)) {\n        return;\n      }\n      switch (key) {\n        case \"d\":\n          theState.debug.show = !theState.debug.show;\n          break;\n        case \"f\":\n          enterFullscreen();\n          break;\n        case \"p\":\n          theState.debug.print = !theState.debug.print;\n          break;\n        case \"s\":\n          const l = theState.image.label;\n          const t = getFormattedTimeStamp();\n          const ext = theState.image.format;\n          const label = `${l}_${t}.${ext}`;\n          console.log(`saving image ${label}`);\n          saveCanvas(label, theState.image.format);\n          break;\n      }\n    }\n  } else {\n    theState.isKeyPressed = false;\n  }\n};\n","import { environmentCheck, initWith } from \"./init\";\n\nconst state = {};\n\n/**\n * Initializes the rxtx connection with the specified app and options.\n *\n * This function sets up the rxtx extension for communication using the provided\n * p5.js sketch and configuration options. It should be called from the\n * `setup` function of your sketch. The configuration options allow for\n * customization of the baud rate, debugging behavior, and other settings.\n *\n * @param {object} theApp - The p5.js sketch instance (`this` from the sketch).\n * @param {object} [theArgs={}] - Configuration options for the connection.\n *\n * @example\n * // Call this function in your p5.js setup function:\n * let options = {\n *   baudRate: 57600,\n *   debug: { print: false, show: false },\n * };\n * rxtx.connect(this, options);\n *\n * @public\n */\nexport const connect = async (theApp, theArgs = {}) => {\n  initWith(theApp, theArgs, state);\n};\n\n/**\n * Checks if values are available in the RXTX state.\n *\n * This function verifies if the `value` field in the RXTX state is defined.\n * Returns `true` if values are available, otherwise `false`. It is designed\n * to be called frequently, such as within a p5.js `draw` function.\n *\n * Usage Example:\n * function draw() {\n *   background(220);\n *\n *   if (rxtx.isValuesAvailable()) {\n *     if (rxtx.getValueAt(0) === 1) {\n *       background(0);\n *     }\n *   }\n *   ...etc\n * }\n *\n * @returns {boolean} `true` if values are available, `false` otherwise.\n * @public\n */\nexport const isValuesAvailable = () => {\n  return state.debug.data.value == undefined ? false : true;\n};\n\nexport const isConnectionEstablished = () => {\n  return state.connected;\n};\n\nexport const isReadyToWrite = () => {\n  return state.io != null;\n};\n\n/**\n * Retrieves the value at the specified index from a list of values.\n *\n * If the index is out of bounds (greater than or equal to the length of\n * the values array), it returns -1. Otherwise, it returns the value\n * at the given index.\n *\n * @param {number} theIndex - The index of the value to retrieve.\n * @returns {*} The value at the specified index, or -1 if out of bounds.\n */\nexport const getValueAt = (theIndex) => {\n  const values = getValues();\n  return theIndex >= values.length ? -1 : values[theIndex];\n};\n\n/**\n * Retrieves the current values from the application state.\n *\n * This function returns the `value` property from the global `state` object.\n * If the `value` property is undefined or null, it defaults to an empty array.\n *\n * @returns {Array} - An array of current values or an empty array if no values\n *                    are set in the state.\n */\nexport const getValues = () => {\n  return state.value || [];\n};\n\n/**\n * Checks the runtime environment for necessary conditions and updates the\n * application state accordingly.\n *\n * @param {Window} window - The global window object, used for browser-related\n * checks.\n * @param {Object} state - The application state object to be updated based on\n * the environment check results.\n *\n * This function verifies if the runtime environment supports the required APIs\n * or features (e.g., Web Serial API) and updates the provided state object\n * with relevant flags or properties, enabling other parts of the application\n * to adapt to the current environment.\n *\n */\nenvironmentCheck(window, state);\n","import { deepMerge, updateState } from \"./utils/processing\";\nimport { startRxtxWith } from \"./serial/setup\";\nimport { keyPressed } from \"./ui/keyboard\";\nimport { showRxtxDebug } from \"./utils/debug\";\n\n/**\n * Initializes the application state with default, user-defined, and internal\n * settings. Merges these settings into `theState` and starts the rxtx process.\n *\n * @param {Object} theApp - The application instance (sketch or object), expected to\n *                          provide properties such as `rxtxEvent` for handling events.\n * @param {Object} theArgs - User-defined settings that override default values.\n *                           Example properties include:\n *                           - baudRate: Communication speed (default: 57600).\n *                           - id: Identifier for the state (default: -1).\n *                           - value: Array of values (default: []).\n *                           - debug: Debugging options { print: false, show: false }.\n * @param {Object} theState - The state object to be initialized with the merged\n *                            settings, including default, user-defined, and\n *                            internal configurations.\n */\nexport const initWith = (theApp, theArgs, theState) => {\n  const defaults = {\n    baudRate: 57600,\n    id: -1,\n    value: [],\n    fn: (ev) => {},\n    image: {\n      label: \"rxtx\",\n      format: \"jpg\",\n    },\n    mappedKeys: [\"d\",\"f\",\"p\",\"s\"],\n    debug: { print: false, show: false },\n  };\n\n  const internal = {\n    debug: { data: {} },\n    connected: false,\n    io: null,\n    isKeyPressed: false,\n    rxtxEvent: theApp.rxtxEvent || ((ev) => {}),\n    readBuffer: \"\",\n    connectedPorts: [],\n  };\n\n  updateState(theState, deepMerge(deepMerge(defaults, theArgs), internal));\n  startRxtxWith(theState);\n};\n\n/**\n * Performs an environment check for the p5.js instance and registers \n * custom behaviors for the window resize and specific \"post\" methods. \n * If p5.js is not found in the global scope, an error is logged.\n * \n * @param {object} theInstance - The global object to check for p5.js.\n * @param {object} theState - The application state object used for \n *                            handling key press and debugging behaviors.\n * \n * - Registers a `windowResized` function to resize the canvas dynamically.\n * - Registers \"post\" methods for handling key presses and debugging.\n * - Logs an error if p5.js is not available in the environment.\n * \n */\nexport const environmentCheck = (theInstance, theState) => {\n  (function (global) {\n    if (global.p5) {\n      global.p5.prototype.windowResized = () => {\n        resizeCanvas(windowWidth, windowHeight);\n      };\n\n      global.p5.prototype.registerMethod(\"post\", () => keyPressed(theState));\n      global.p5.prototype.registerMethod(\"post\", () => showRxtxDebug(theState));\n    } else {\n      console.error(\n        \"p5.js not found. Please include p5.js before this library.\",\n      );\n    }\n  })(theInstance);\n};\n","/**\n * Displays debugging information for the RXTX state.\n *\n * This function logs and visualizes the debug data stored in the `theState`\n * object. It first checks whether debugging options are enabled (`print` and\n * `show`) and whether valid data is available. If data is present and the\n * `show` option is enabled, a graphical layer is created or updated to display\n * the data as a list of visualized values on the canvas.\n *\n * The debug output includes:\n * - Text logging of debug data if `print` is enabled.\n * - A graphical representation of values, showing constrained bars and\n *   corresponding numeric labels.\n * - Integration with WebGL mode by offsetting the canvas transformation.\n *\n * @param {Object} theState - The state object containing debug information.\n */\nexport const showRxtxDebug = (theState) => {\n  if (theState.debug === undefined) return;\n  if (theState.debug.print) {\n    if (theState.debug.data.value == undefined) {\n      console.log(\"debug.print, no data present yet.\");\n    } else {\n      console.log(theState.debug.data.value);\n    }\n  }\n  if (!theState.debug.show || !theState.debug.data.value) return;\n\n  const isWEBGL = drawingContext instanceof WebGLRenderingContext;\n\n  const v = theState.debug.data.value;\n  const id = theState.debug.data.id;\n  const label = `Device ${id}`;\n  const spacing = 20;\n  const header = 40;\n  const footer = 20;\n  const h = header + v.length * spacing + footer;\n  const w = 400;\n  if (!theState.debug.layer) {\n    theState.debug.layer = createGraphics(w, h);\n    theState.debug.layer.clear();\n  }\n  const l = theState.debug.layer;\n  l.clear();\n  l.noStroke();\n  l.fill(0, 40);\n  l.rect(0, 0, w, h, 16);\n  l.push();\n  l.translate(20, 20);\n  l.fill(255);\n  l.text(label, 0, 0);\n  l.translate(0, 20);\n  v.forEach((v, i) => {\n    let v0 = constrain(v, 0, 1);\n    l.push();\n    l.translate(0, i * 20);\n    l.fill(255, 40);\n    l.rect(0, 0, 300, 10, 4);\n    l.fill(255, 200);\n    l.rect(0, 2, v0 * 300, 8, 4);\n    l.fill(255);\n    l.text(v0.toFixed(2), 320, 10);\n    l.pop();\n  });\n  l.pop();\n\n  push();\n  if (isWEBGL) {\n    translate(-width / 2, -height / 2);\n  }\n  translate(20, 20);\n  image(theState.debug.layer, 0, 0);\n  pop();\n};\n\nexport const log = (...args) => {\n  let msg = ``;\n  args.forEach((el) => {\n    if (el instanceof Object) {\n      msg += `\\n${JSON.stringify(el, null, 2)}`;\n    } else {\n      msg += el;\n    }\n  });\n  console.log(\"rxtx debug : \", msg);\n};\n"],"names":["deepMerge","target","source","key","Array","isArray","updateState","theState","updates","Object","assign","handleIncomingData","value","includes","readBuffer","data","remainder","split","async","theString","JSON","parse","error","id","parseStringToJSON","then","parsedData","debug","fn","rxtxEvent","catch","err","console","log","getAvailablePorts","navigator","Error","serial","getPorts","selectPort","requestPort","connectToPort","thePort","open","baudRate","decoder","TextDecoderStream","reader","readable","pipeTo","writable","getReader","writer","getWriter","connectedPorts","push","getInfo","connected","port","io","readFromPort","cleanupResources","done","read","cancel","releaseLock","close","startRxtxWith","length","addConnectButton","ports","reconnectToPreviouslyGrantedPorts","button","createButton","position","style","mouseOver","mouseOut","mousePressed","val","remove","isConnected","checkPortConnectionFor","document","ontouchmove","event","preventDefault","keyPressed","isKeyPressed","mappedKeys","show","fullscreen","print","label","image","t","year","nf","month","day","hour","minute","second","getFormattedTimeStamp","format","saveCanvas","state","connect","theApp","theArgs","internal","ev","initWith","isValuesAvailable","isConnectionEstablished","isReadyToWrite","getValueAt","theIndex","values","getValues","theInstance","global","window","p5","prototype","windowResized","resizeCanvas","windowWidth","windowHeight","registerMethod","isWEBGL","drawingContext","WebGLRenderingContext","v","h","layer","createGraphics","clear","l","noStroke","fill","rect","translate","text","forEach","i","v0","constrain","toFixed","pop","width","height","showRxtxDebug"],"mappings":"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"}