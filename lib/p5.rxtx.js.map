{"version":3,"file":"p5.rxtx.js","sources":["../src/utils/processing.js","../src/serial/data.js","../src/serial/port.js","../src/serial/setup.js","../src/ui/window.js","../src/ui/keyboard.js","../src/utils/debug.js","../src/init.js","../src/main.js"],"sourcesContent":["/**\n * Parses a JSON string and returns the resulting object.\n * If parsing fails, it returns a default object with an `id` of -1.\n *\n * @param {string} theString - The JSON string to be parsed.\n * @returns {Object} - The parsed JSON object, or a default object \n * if parsing fails.\n */\nexport const parseStringToJSON = async (theString) => {\n  try {\n    let json = JSON.parse(theString);\n    return json;\n  } catch (error) {\n    return { id: -1, value: [], type: \"error\" };\n  }\n};\n\n/**\n * Parses a string into an array of numbers or a single floating-point \n * number. If the string starts with '[', it is treated as a comma-separated \n * list of numbers. Otherwise, the string is parsed as a single float.\n *\n * @param {string} theData - The input string to be parsed.\n * @returns {number[]|number} - An array of numbers if the input represents a \n * list, or a single floating-point number if it does not.\n *\n * @example\n * parseStringToArray(\"[1, 2, 3]\"); // Returns [1, 2, 3]\n * parseStringToArray(\"42.5\");     // Returns 42.5\n */\nexport const parseStringToArray = (theData) => {\n  if (theData.charAt(0) == \"[\") {\n    let str0 = theData;\n    let str1 = str0.trim().replace(/[`\\[\\]\\\\\\/]/gi, \"\");\n    let arr0 = str1.split(\",\");\n    let arr1 = arr0.map(Number);\n    return arr1;\n  } else {\n    // @TODO do we want that here or should this default\n    // to an array with a single element.\n    return float(theData);\n  }\n};\n\n/**\n * Converts a string to an ArrayBuffer.\n *\n * This function takes a string and encodes it into an ArrayBuffer where each \n * character is represented by 2 bytes (UTF-16). The resulting ArrayBuffer can \n * be used for binary data manipulation.\n *\n * @param {string} theString - The input string to be converted.\n * @returns {ArrayBuffer} The resulting ArrayBuffer containing the encoded string.\n *\n * Example:\n * const buffer = str2ab(\"hello\");\n * console.log(buffer); // ArrayBuffer { byteLength: 10 }\n */\nexport const str2ab = (theString) => {\n  var buf = new ArrayBuffer(theString.length * 2); // 2 bytes for each char\n  var bufView = new Uint16Array(buf);\n  for (var i = 0, strLen = theString.length; i < strLen; i++) {\n    bufView[i] = theString.charCodeAt(i);\n  }\n  return buf;\n};\n\n/**\n * Recursively merges the properties of a source object into a target object.\n * If a property in the source is an object, it performs a deep merge. Arrays\n * are not deeply merged but overwritten. The target object is modified and\n * returned.\n *\n * @param {Object} target - The object to receive properties from the source.\n * @param {Object} source - The object whose properties are merged into the\n * target.\n * @returns {Object} - The modified target object after merging.\n *\n * @example\n * const target = { a: 1, b: { c: 2 } };\n * const source = { b: { d: 3 }, e: 4 };\n * const result = deepMerge(target, source);\n * console.log(result); // { a: 1, b: { c: 2, d: 3 }, e: 4 }\n */\nexport const deepMerge = (target, source) => {\n  for (const key in source) {\n    if (\n      source[key] && typeof source[key] === \"object\" &&\n      !Array.isArray(source[key])\n    ) {\n      target[key] = deepMerge(target[key] || {}, source[key]);\n    } else {\n      target[key] = source[key];\n    }\n  }\n  return target;\n};\n\n/**\n * Updates the given state object with new properties.\n * \n * This function merges the `updates` object into `theState` using\n * shallow copying. Existing properties in `theState` are overwritten \n * if they exist in `updates`, while new properties are added.\n * \n * @param {Object} theState - The state object to update.\n * @param {Object} updates - The object containing properties to merge\n *                           into the state.\n * \n * @example\n * const state = { a: 1, b: 2 };\n * updateState(state, { b: 3, c: 4 });\n * console.log(state); // { a: 1, b: 3, c: 4 }\n */\nexport const updateState = (theState, updates) => {\n  Object.assign(theState, updates);\n};\n\n/**\n * Generates a formatted timestamp string.\n *\n * This function constructs a timestamp in the format `YYYYMMDDHHmmSS` using\n * the current date and time. Each component (month, day, hour, minute, and\n * second) is zero-padded to ensure a consistent two-digit format.\n *\n * @returns {string} A timestamp string in the format `YYYYMMDDHHmmSS`.\n *\n * Example:\n *   If the current date and time is December 1, 2023, 15:05:09, the output\n *   will be: \"20231201150509\".\n */\nexport const getFormattedTimeStamp = () => {\n  let t = year() + nf(month(), 2) + nf(day(), 2);\n  t += nf(hour(), 2) + nf(minute(), 2) + nf(second(), 2);\n  return t;\n};\n","import { parseStringToJSON, updateState } from \"../utils/processing\";\n\nconst utf8EncodeText = new TextEncoder();\n\n/**\n * Sends data to the connected serial device via the Web Serial API.\n *\n * @async\n * @function rxtxSendTo\n * @param {Object} theState - The current application state, including the\n *                            serial port and writer.\n * @param {String} theString - The data to be sent to the serial device. This data\n *                      will be processed before being written.\n * @returns {Promise<boolean>} Returns true if the data was successfully sent,\n *                             or false if no port is available in the state.\n *\n * @example\n * const state = { port: somePort, writer: someWriter };\n * const success = await rxtxSendTo(state, \"{id:1, value:[1,2]}\");\n * console.log(success); // true if data was sent successfully\n */\nexport const rxtxSendTo = async (theState, theString) => {\n  if (!theState?.port) return false;\n  await theState.writer.write(checkRxtxData(theString));\n  return true;\n};\n\nconst checkRxtxData = (theData) => {\n  // see sketch https://editor.p5js.org/sojamo/sketches/yXZauy17X\n  // to type check, then operate on theData accordingly\n  // and return expected type so that it can be interpreted\n  // by the receiving end, the Arduino.\n  return utf8EncodeText.encode(theData);\n};\n\n/**\n * Processes incoming data from a serial stream, handling partial and complete\n * data chunks. Appends incomplete data to a buffer until a newline character\n * (`\\n`) is detected, at which point the buffer is parsed as JSON. Updates the\n * application state and triggers related events upon successful parsing.\n *\n * @param {string} value - Incoming data chunk from the serial stream.\n * @param {object} theState - Application state object that holds the buffer,\n *                            parsed data, and callback functions.\n *\n * @throws {Error} Logs an error if parsing the buffer as JSON fails.\n *\n * @example\n * handleIncomingData(\"[1,2,3]\\n\", theState);\n * // Parses \"[1,2,3]\" as JSON, updates the state, and triggers events.\n */\nexport const handleIncomingData = (value, theState) => {\n  if (!value.includes(\"\\n\")) {\n    theState.readBuffer += value;\n    return;\n  }\n  const [data, remainder] = value.split(\"\\n\");\n  theState.readBuffer += data;\n  parseStringToJSON(theState.readBuffer)\n    .then((parsedData) => {\n      if (parsedData.value !== undefined) {\n        \n        // @TODO fix this messy looking data transfer\n        const { id, value } = parsedData;\n        theState.debug.data = { value, id };\n        updateState(theState, {\n          value: value || [],\n          id: id || -1,\n          // debug: { data: theState }, // @TODO look into this assignment, overrides debug settings\n        });\n\n        theState.rxtxEvent({ \n          id: theState.id, \n          value: theState.value,\n          getValueAt: (theIndex) => theState.value[theIndex]\n        });\n      }\n      theState.readBuffer = remainder || \"\";\n    })\n    .catch((err) => console.log(\"Error parsing data:\", err));\n};\n","import { handleIncomingData } from \"./data\";\nimport { updateState } from \"../utils/processing\";\n\n/**\n * Retrieves all available serial ports that the user has\n * previously granted permission to access.\n *\n * This function utilizes the Web Serial API to list serial\n * ports that are currently available and for which the browser\n * has retained user permissions. If the Web Serial API is not\n * supported by the browser, an error is thrown.\n *\n * @async\n * @function getAvailablePorts\n * @throws {Error} If the Web Serial API is not supported by the browser.\n * @returns {Promise<SerialPort[]>} A promise that resolves to an array\n *                                  of `SerialPort` objects representing\n *                                  the available serial ports.\n */\nexport const getAvailablePorts = async () => {\n  if (!(\"serial\" in navigator)) {\n    throw new Error(\"Web Serial API not supported.\");\n  }\n  return await navigator.serial.getPorts();\n};\n\n/**\n * Attempts to reconnect to all previously granted serial ports.\n *\n * This function retrieves a list of previously granted serial ports using\n * `getAvailablePorts`, then iterates over each port to establish a connection\n * by calling `connectToPort`. The state (`theState`) is updated during each\n * connection attempt.\n *\n * @async\n * @param {Object} theState - The application state object used to manage\n *                            connections and serial port details.\n */\nexport const reconnectToPreviouslyGrantedPorts = async (theState) => {\n  const ports = await getAvailablePorts();\n  console.log(\"trying to reconnect to previous port(s)\", ports);\n\n  for (const port of ports) {\n    const connected = await connectToPort(port, theState);\n  }\n};\n\n/**\n * Checks and establishes a connection to a serial port for the given state.\n *\n * This function initializes the `readBuffer` in the provided state and attempts\n * to retrieve available serial ports. If no ports are available, it prompts\n * the user to select a port. Otherwise, it selects the first available port.\n * Once a port is identified, the function attempts to connect to it.\n *\n * @async\n * @function checkPortConnectionFor\n * @param {Object} theState - The application state object. It should contain\n *                            the required properties for managing the serial\n *                            connection and the read buffer.\n * @returns {Promise<boolean>} - Resolves to `true` if the connection is\n *                               successfully established; otherwise, `false`.\n */\nexport const checkPortConnectionFor = async (theState) => {\n  theState.readBuffer = \"\";\n\n  // Get available ports\n  const ports = await getAvailablePorts();\n\n  let port;\n  if (ports.length === 0) {\n    // Select a port if none are available\n    port = await selectPort();\n  } else {\n    // Select the first port available from the ports list\n    port = ports.length > 0 ? ports[0] : null;\n  }\n  return await connectToPort(port, theState);\n};\n\n/**\n * Prompts the user to select a serial port using the Web Serial API.\n *\n * This function uses `navigator.serial.requestPort()` to request a serial\n * port from the user. If the user selects a port, the function resolves with\n * the selected port. If an error occurs or the user cancels the selection, the\n * function logs the error and explicitly returns `undefined`.\n *\n * @returns {Promise<SerialPort | undefined>} A promise that resolves with the\n * selected `SerialPort` object if successful, or `undefined` if an error\n * occurs or no port is selected.\n */\nconst selectPort = async () => {\n  try {\n    // Request a port from the user\n    const port = await navigator.serial.requestPort();\n    return port; // Return the selected port\n  } catch (err) {\n    console.log(\"Error selecting port:\", err);\n    return undefined; // Explicitly return undefined on error\n  }\n};\n\n/**\n * Asynchronously connects to a given serial port and updates the state object.\n *\n * This function opens the specified serial port with the baud rate provided in\n * the state object. It sets up the necessary streams for reading and writing\n * data, stores the connection details, and initiates data reading from the port.\n * If the connection is successful, the state is updated accordingly.\n *\n * @async\n * @function connectToPort\n * @param {SerialPort} thePort - The serial port to connect to.\n * @param {Object} theState - The state object containing configuration and\n *                            where connection details will be stored.\n * @returns {Promise<boolean>} - Resolves to `true` if connection is successful,\n *                               otherwise `false`.\n *\n * @throws Will throw an error if the connection fails.\n */\nconst connectToPort = async (thePort, theState) => {\n  if (!thePort) {\n    console.log(\"No port provided.\");\n    return false;\n  }\n\n  try {\n    // Open the port with the given baud rate\n    await thePort.open({ baudRate: theState.baudRate });\n\n    // Set up text decoding for the readable stream\n    const decoder = new TextDecoderStream();\n    const inputDone = thePort.readable.pipeTo(decoder.writable);\n\n    // Retrieve reader and writer\n    const reader = decoder.readable.getReader();\n    const writer = thePort.writable.getWriter();\n\n    // Store the connected port and streams\n    theState.connectedPorts.push({ thePort, reader, writer });\n\n    // Log successful connection\n    console.log(\"Serial communication established with\", thePort.getInfo());\n\n    // Update the state\n    updateState(theState, {\n      connected: true,\n      port: thePort,\n      reader,\n      writer,\n      io: true, // @TODO: Decide if io is redundant\n    });\n    \n  } catch (err) {\n    console.log(\"Error connecting to port:\", err);\n\n    cleanupResources(thePort, theState).then(() =>\n      console.log(\"Resources cleaned up.\")\n    ).catch(console.error);\n\n    updateState(theState, {\n      connected: false,\n      port: thePort,\n      reader: null,\n      writer: null,\n      io: false, // @TODO: Decide if io is redundant\n    });\n    throw new Error(\"Failed to connect\");\n  }\n\n  await readFromPort(theState);\n  return false;\n};\n\n/**\n * Reads data from the connected serial port in an asynchronous loop.\n *\n * Continuously reads incoming data from the port while the connection\n * remains active (`theState.connected`). Passes the data to a handler\n * function for processing. If an error occurs during reading, logs\n * the error and throws it for upstream handling. Ensures resources\n * like the reader and port are cleaned up when the reading stops or\n * an error occurs.\n *\n * @param {Object} theState - The application state object containing:\n *  - `connected` (boolean): Whether the port is connected.\n *  - `reader` (ReadableStreamDefaultReader): The port's reader for incoming data.\n *  - `port` (SerialPort): The connected serial port.\n *\n * @throws {Error} Re-throws any error encountered during reading.\n */\nconst readFromPort = async (theState) => {\n  try {\n    while (theState.connected) {\n      const { value, done } = await theState.reader.read();\n      if (done) break;\n      if (value) handleIncomingData(value, theState);\n    }\n  } catch (err) {\n    console.log(\"Error during read:\", err);\n    throw err;\n  } finally {\n    cleanupResources(theState.port, theState).then(() =>\n      console.log(\"Resources cleaned up.\")\n    ).catch(console.error);\n  }\n};\n\n/**\n * Cleans up serial port resources by canceling and releasing reader\n * and writer locks. Ensures proper closure of streams to prevent\n * resource leaks.\n *\n * @param {SerialPort} thePort - The serial port to be cleaned up (optional).\n * @param {Object} theState - The application state containing reader and writer.\n * @returns {Promise<void>} Resolves when cleanup is complete.\n */\nconst cleanupResources = async (thePort, theState) => {\n  // @TODO cleanup theState\n\n  try {\n    if (theState.reader) {\n      await theState.reader.cancel();\n      theState.reader.releaseLock();\n    }\n    if (theState.writer) {\n      await theState.writer.close();\n      theState.writer.releaseLock();\n    }\n  } catch (err) {\n    console.log(\"Error during cleanup:\", err);\n  }\n};\n","import {\n  checkPortConnectionFor,\n  getAvailablePorts,\n  reconnectToPreviouslyGrantedPorts,\n} from \"./port\";\n\n/**\n * Initializes the rxtx extension by checking available serial ports and managing\n * connection states. If no ports are detected, it adds a \"Connect\" button\n * to prompt the user for manual port selection. If ports are available, it\n * attempts to reconnect to previously granted ports.\n *\n * @async\n * @function startRxtxWith\n * @param {Object} theState - The application state object that holds serial\n *                            connection information and configurations.\n * @returns {Object} Updated state object after processing available ports.\n */\n\nexport const startRxtxWith = async (theState) => {\n  const availablePorts = await getAvailablePorts();\n  // @TODO update state before returning\n  switch (availablePorts.length) {\n    case 0:\n      console.log(\"No previously granted ports detected, add connect button.\");\n      await addConnectButton(theState);\n      break;\n    default:\n      console.log(\"Previously granted ports detected, wait to reconnect ..\");\n      try {\n        await reconnectToPreviouslyGrantedPorts(theState);\n      } catch (err) {\n        console.log(\"couldn't reconnect to previously granted port(s).\");\n        await addConnectButton(theState, false);\n      }\n      break;\n  }\n  return theState;\n};\n\n/**\n * Adds a \"connect\" button to the interface for establishing a serial connection.\n *\n * The button is styled and positioned on the screen. When pressed, it attempts\n * to connect to a serial port using the provided state. If the connection fails,\n * the button is re-added for retrying. The button changes color on hover to\n * provide feedback to the user.\n *\n * @param {Object} theState - An object representing the current application state.\n *                            Includes configuration and callbacks for connection.\n *\n * Usage:\n * Call this function to display a \"connect\" button on the interface, allowing\n * users to establish a connection.\n */\n\nconst addConnectButton = async (theState, available = true) => {\n  // @TODO check if button already exists to avoid more\n  // than 1 instances at the same time\n  const label = available ? \"connect\" : \"unavailable\";\n  const col = available ? [\"#03a1ff\", \"#06b004\"] : [\"#ffa103\", \"#666666\"];\n  const button = createButton(label);\n  button.position(20, 20);\n  button.style(`\n    background: ${col[0]};\n    color: #fff;\n    font-size: 16px;\n    margin: auto;\n    border: 0;\n    padding: 8px 32px;\n    border-radius: 32px;\n    transition: background 0.3s;\n  `);\n\n  button.mouseOver(() => button.style(`background: ${col[1]};`));\n  button.mouseOut(() => button.style(`background: ${col[0]};`));\n\n  button.mousePressed(async () => {\n    \n    // remove the button before checkPortConnectionFor\n    // in the next step goes into while-loop mode\n    button.remove();\n    try {\n      // we have a connection\n      await checkPortConnectionFor(theState);\n    } catch (err) {\n      // we can't connect\n      console.log(`port is busy, ${err.message}`);\n      addConnectButton(theState, false); \n    }\n  });\n};\n","/**\n * Toggles the application to enter fullscreen mode.\n *\n * This function checks if the application is not currently in fullscreen\n * mode using the `fullscreen()` function. If not in fullscreen, it switches\n * the application to fullscreen mode by setting `fullscreen(true)`.\n *\n * Note:\n * - This function assumes the presence of the `fullscreen()` utility, \n *   provided by p5.js.\n */\nexport const enterFullscreen = () => {\n  var fs = fullscreen();\n  if (!fs) {\n    fullscreen(true);\n  }\n};\n\n/**\n * Prevents touch move events on the document.\n *\n * This function disables the default behavior of touch move events,\n * such as scrolling or panning, when a user drags their finger across\n * the screen. Useful for applications where touch gestures should be\n * intercepted or restricted.\n *\n * @param {TouchEvent} event - The touch event triggered by a user's interaction.\n */\ndocument.ontouchmove = (event) => {\n  event.preventDefault();\n};","import { enterFullscreen } from \"./window\";\nimport { getFormattedTimeStamp } from \"../utils/processing\";\n\n// @NOTE: Application version - injected from package.json during \n// production build, defaults to 'dev-version' during development\n// handled by vite plugin vite.plugin.version.js\nconst VERSION = /* @INJECT_VERSION */ || 'dev-version';\n\n/**\n * Handles keypress events and updates the application state based on the\n * pressed key. Supports toggling debug modes, entering fullscreen,\n * and saving a canvas image. Checks for allowed keys and ensures state\n * consistency during keypress handling.\n * \n * Mapped keys can be dis/enabled with the mappedKeys option\n * @see initWith - Initializes the state with default, user-defined, settings\n *\n * @param {Object} theState - The current application state. Includes:\n *   - {boolean} isKeyPressed - Tracks whether a key is currently pressed.\n *   - {Object} debug - Manages debug settings:\n *       - {boolean} show - Toggles debug display.\n *       - {boolean} print - Toggles debug print mode.\n *   - {Array<string>} mappedKeys - Allowed keys for handling.\n *   - {Object} image - Contains image properties:\n *       - {string} format - File format for saved images.\n *       - {string} label - Prefix label for saved images.\n * \n */\nexport const keyPressed = (theState) => {\n  if (isKeyPressed === true) {\n    if (theState.isKeyPressed === false) {\n      theState.isKeyPressed = true;\n      if (!theState.mappedKeys.includes(key)) {\n        return;\n      }\n      // @NOTE: to add a new mapped key, you need \n      // to add that key to the mappedKeys array (init.js)\n      switch (key) {\n        case \"d\":\n          theState.debug.show = !theState.debug.show;\n          break;\n        case \"f\":\n          enterFullscreen();\n          break;\n        case \"p\":\n          theState.debug.print = !theState.debug.print;\n          break;\n        case \"s\":\n          const l = theState.image.label;\n          const t = getFormattedTimeStamp();\n          const ext = theState.image.format;\n          const label = `${l}_${t}.${ext}`;\n          console.log(`saving image ${label}`);\n          saveCanvas(label, theState.image.format);\n          break;\n        case \"v\":\n          console.log(`p5.rxtx ${VERSION} by sojamo`);\n          break;\n      }\n    }\n  } else {\n    theState.isKeyPressed = false;\n  }\n};\n","/**\n * Main debug information display handler for rxtx state\n * @param {Object} theState - The state object containing debug information\n */\nexport const showRxtxDebug = (theState) => {\n  if (theState.debug === undefined) return;\n\n  handleDebugPrinting(theState);\n  if (!theState.debug.show || !theState.debug.data.value) return;\n\n  const dimensions = calculateDebugDimensions(theState.debug.data.value.length);\n  updateRanges(theState);\n\n  const layer = createOrUpdateDebugLayer(theState, dimensions);\n  drawDebug(theState, layer, dimensions);\n};\n\n/**\n * Handles console logging of debug data\n * @param {Object} theState - The state object\n */\nconst handleDebugPrinting = (theState) => {\n  if (!theState.debug.print) return;\n\n  if (theState.debug.data.value == undefined) {\n    console.log(\"debug.print, no data present yet.\");\n  } else {\n    console.log(theState.debug.data.value);\n  }\n};\n\n/**\n * Calculates dimensions for debug visualization\n * @param {number} theValueCount - Number of values to display\n * @returns {Object} Width, height, and layout parameters\n */\nconst calculateDebugDimensions = (theValueCount) => {\n  const spacing = 20;\n  const header = 40;\n  const footer = 20;\n  return {\n    width: 400,\n    height: header + theValueCount * spacing + footer,\n    spacing,\n    header,\n    footer,\n    barLength: 300,\n  };\n};\n\n/**\n * Updates value ranges in the state\n * @param {Object} theState - The state object\n */\nconst updateRanges = (theState) => {\n  const values = theState.debug.data.value;\n  const r0 = theState.range || [];\n  theState.range = updateRangeFor(values, r0);\n\n  values.forEach((v0, i) => {\n    theState.range[i].min = v0 < theState.range[i].min\n      ? v0\n      : theState.range[i].min;\n    theState.range[i].max = v0 > theState.range[i].max\n      ? v0\n      : theState.range[i].max;\n  });\n};\n\n/**\n * Creates or updates the graphics layer for debug visualization\n * @param {Object} theState - The state object\n * @param {Object} theDimensions - Layout dimensions\n * @returns {Object} Graphics layer\n */\nconst createOrUpdateDebugLayer = (theState, theDimensions) => {\n  if (!theState.debug.layer) {\n    theState.debug.layer = createGraphics(\n      theDimensions.width,\n      theDimensions.height,\n    );\n    theState.debug.layer.clear();\n  }\n  return theState.debug.layer;\n};\n\n/**\n * Draws the debug visualization\n * @param {Object} theState - The state object\n * @param {Object} theLayer - Graphics layer to draw on\n * @param {Object} theDimensions - Layout dimensions\n */\nconst drawDebug = (theState, theLayer, theDimensions) => {\n  drawBackground(theLayer, theDimensions);\n  drawHeader(theLayer, theState.debug.data.id);\n  drawValueBars(\n    theLayer,\n    theState.debug.data.value,\n    theState.range,\n    theDimensions,\n  );\n  renderFinalOutput(theLayer, isWebGLContext());\n};\n\n/**\n * Draws the background for debug visualization\n * @param {Object} theLayer - Graphics layer to draw on\n * @param {Object} theDimensions - Layout dimensions\n */\nconst drawBackground = (theLayer, theDimensions) => {\n  theLayer.clear();\n  theLayer.noStroke();\n  theLayer.fill(0, 40);\n  theLayer.rect(0, 0, theDimensions.width, theDimensions.height, 16);\n};\n\n/**\n * Draws the header with device ID\n * @param {Object} theLayer - Graphics layer to draw on\n * @param {string} theDeviceId - Device identifier\n */\nconst drawHeader = (theLayer, theDeviceId) => {\n  theLayer.push();\n  theLayer.translate(20, 20);\n  theLayer.fill(255);\n  theLayer.text(`Device ${theDeviceId}`, 0, 0);\n  theLayer.pop();\n};\n\n/**\n * Draws the value bars with their corresponding numbers\n * @param {Object} theLayer - Graphics layer to draw on\n * @param {Array} theValue - Array of values to visualize\n * @param {Array} theRanges - Array of min/max ranges for each value\n * @param {Object} theDimensions - Layout dimensions\n */\nconst drawValueBars = (theLayer, theValue, theRanges, theDimensions) => {\n  theLayer.push();\n  theLayer.translate(20, 40); // Offset after header\n\n  theValue.forEach((value, i) => {\n    const mappedValue = map(value, theRanges[i].min, theRanges[i].max, 0, 1);\n\n    theLayer.push();\n    theLayer.translate(0, i * theDimensions.spacing);\n\n    // Background bar\n    theLayer.fill(255, 40);\n    theLayer.rect(0, 0, theDimensions.barLength, 10, 4);\n\n    // Value bar\n    theLayer.fill(255, 200);\n    theLayer.rect(0, 2, mappedValue * theDimensions.barLength, 8, 4);\n\n    // Value text\n    theLayer.fill(255);\n    theLayer.text(value.toFixed(2), theDimensions.barLength + 20, 10);\n\n    theLayer.pop();\n  });\n\n  theLayer.pop();\n};\n\n/**\n * Renders the final output to the screen\n * @param {Object} theLayer - Graphics layer to render\n * @param {boolean} isWebGL - Whether we're in WebGL mode\n */\nconst renderFinalOutput = (theLayer, isWebGL) => {\n  push();\n\n  if (isWebGL) {\n    translate(-width / 2, -height / 2);\n  }\n\n  translate(20, 20);\n  image(theLayer, 0, 0);\n\n  pop();\n};\n\n/**\n * Checks if current context is WebGL\n * @returns {boolean} True if WebGL context\n */\nconst isWebGLContext = () => {\n  return drawingContext instanceof WebGLRenderingContext ||\n    drawingContext instanceof WebGL2RenderingContext;\n};\n\n/**\n * Synchronizes the range array size with the value array size.\n * Adds or removes elements from the range array to match the value array length.\n * New range elements are initialized with {min: 0, max: 1}.\n *\n * @param {Array} theValue - Source array to match length against\n * @param {Array} theRange - Target array to be resized\n * @returns {Array} Updated range array with matching length\n *\n * Example:\n * If theValue.length = 3 and theRange.length = 1\n * Result: theRange will be expanded to length 3 with new {min:0, max:1} elements\n */\nconst updateRangeFor = (theValue, theRange) => {\n  const valueDiff = theValue.length - theRange.length;\n\n  if (valueDiff > 0) {\n    // Add new elements to range\n    const newElements = Array(valueDiff).fill().map(() => ({ min: 0, max: 1 }));\n    theRange = [...theRange, ...newElements];\n  } else if (valueDiff < 0) {\n    // Remove excess elements from range\n    theRange = theRange.slice(0, value.length);\n  }\n  return theRange;\n};\n","import { deepMerge, updateState } from \"./utils/processing\";\nimport { startRxtxWith } from \"./serial/setup\";\nimport { keyPressed } from \"./ui/keyboard\";\nimport { showRxtxDebug } from \"./utils/debug\";\n\n/**\n * Initializes the application state with default, user-defined, and internal\n * settings. Merges these settings into `theState` and starts the rxtx process.\n *\n * @param {Object} theApp - The application instance (sketch or object), expected to\n *                          provide properties such as `rxtxEvent` for handling events.\n * @param {Object} theArgs - User-defined settings that override default values.\n *                           Example properties include:\n *                           - baudRate: Communication speed (default: 57600).\n *                           - id: Identifier for the state (default: -1).\n *                           - value: Array of values (default: []).\n *                           - debug: Debugging options { print: false, show: false }.\n * @param {Object} theState - The state object to be initialized with the merged\n *                            settings, including default, user-defined, and\n *                            internal configurations.\n */\nexport const initWith = (theApp, theArgs, theState) => {\n  const defaults = {\n    baudRate: 57600,\n    id: -1,\n    value: [],\n    range: [],\n    image: {\n      label: \"rxtx\",\n      format: \"jpg\",\n    },\n    mappedKeys: [\"d\", \"f\", \"p\", \"s\", \"v\"],\n    debug: { print: false, show: false },\n  };\n\n  const internal = {\n    debug: { data: {} },\n    connected: false,\n    io: null,\n    isKeyPressed: false,\n    rxtxEvent: theApp.rxtxEvent || ((ev) => {}),\n    readBuffer: \"\",\n    connectedPorts: [],\n  };\n\n  updateState(theState, deepMerge(deepMerge(defaults, theArgs), internal));\n  startRxtxWith(theState);\n};\n\n/**\n * Performs an environment check for the p5.js instance and registers\n * custom behaviors for the window resize and specific \"post\" methods.\n * If p5.js is not found in the global scope, an error is logged.\n *\n * @param {object} theInstance - The global object to check for p5.js.\n * @param {object} theState - The application state object used for\n *                            handling key press and debugging behaviors.\n *\n * - Registers a `windowResized` function to resize the canvas dynamically.\n * - Registers \"post\" methods for handling key presses and debugging.\n * - Logs an error if p5.js is not available in the environment.\n */\nexport const environmentCheck = (theInstance, theState) => {\n  (function (global) {\n    if (global.p5) {\n      global.p5.prototype.windowResized = () => {\n        resizeCanvas(windowWidth, windowHeight);\n      };\n\n      global.p5.prototype.registerMethod(\"post\", () => keyPressed(theState));\n      global.p5.prototype.registerMethod(\"post\", () => showRxtxDebug(theState));\n    } else {\n      console.error(\n        \"p5.js not found. Please include p5.js before this library.\",\n      );\n    }\n  })(theInstance);\n};\n","import { environmentCheck, initWith } from \"./init\";\nimport { rxtxSendTo } from \"./serial/data\";\n\nconst state = {};\n\n/**\n * Initializes the rxtx connection with the specified app and options.\n *\n * This function sets up the rxtx extension for communication using the provided\n * p5.js sketch and configuration options. It should be called from the\n * `setup` function of your sketch. The configuration options allow for\n * customization of the baud rate, debugging behavior, and other settings.\n *\n * @param {object} theApp - The p5.js sketch instance (`this` from the sketch).\n * @param {object} [theArgs={}] - Configuration options for the connection.\n *\n * @example\n * // Call this function in your p5.js setup function:\n * let options = {\n *   baudRate: 57600,\n *   debug: { print: false, show: false },\n * };\n * rxtx.connect(this, options);\n *\n * @public\n */\nexport const connect = async (theApp, theArgs = {}) => {\n  initWith(theApp, theArgs, state);\n};\n\n/**\n * Checks if values are available in the rxtx state.\n *\n * This function verifies if the `value` field in the RXTX state is defined.\n * Returns `true` if values are available, otherwise `false`. It is designed\n * to be called frequently, such as within a p5.js `draw` function.\n *\n * Usage Example:\n * function draw() {\n *   background(220);\n *\n *   if (rxtx.isValuesAvailable()) {\n *     if (rxtx.getValueAt(0) === 1) {\n *       background(0);\n *     }\n *   }\n *   ...etc\n * }\n *\n * @returns {boolean} `true` if values are available, `false` otherwise.\n * @public\n */\nexport const isValuesAvailable = () => {\n  return state.debug.data.value == undefined ? false : true;\n};\n\nexport const isConnectionEstablished = () => {\n  return state.connected;\n};\n\nexport const isReadyToSend = () => {\n  return state.io != null;\n};\n\n/**\n * Retrieves the value at the specified index from a list of values.\n *\n * If the index is out of bounds (greater than or equal to the length of\n * the values array), it returns -1. Otherwise, it returns the value\n * at the given index.\n *\n * @param {number} theIndex - The index of the value to retrieve.\n * @returns {*} The value at the specified index, or -1 if out of bounds.\n */\nexport const getValueAt = (theIndex) => {\n  const values = getValues();\n  return theIndex >= values.length ? -1 : values[theIndex];\n};\n\n/**\n * Retrieves the current values from the application state.\n *\n * This function returns the `value` property from the global `state` object.\n * If the `value` property is undefined or null, it defaults to an empty array.\n *\n * @returns {Array} - An array of current values or an empty array if no values\n *                    are set in the state.\n */\nexport const getValues = () => {\n  return state.value || [];\n};\n\nexport const send = (theJSONformattedData) => {\n  const str = JSON.stringify(theJSONformattedData);\n  rxtxSendTo(state, str);\n};\n\n/**\n * Checks the runtime environment for necessary conditions\n * and updates the application state accordingly.\n *\n * @param {Window} window - The global window object, used\n * for browser-related checks.\n * @param {Object} state - The application state object to\n * be updated based on the environment check results.\n *\n * This function verifies if the runtime environment supports\n * the required APIs or features (e.g., Web Serial API) and updates\n * the provided state object with relevant flags or properties,\n * enabling other parts of the application to adapt to the\n * current environment.\n */\nenvironmentCheck(window, state);\n"],"names":["key","value"],"mappings":"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"}