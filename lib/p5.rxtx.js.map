{"version":3,"file":"p5.rxtx.js","sources":["../src/rxtx.processing.js","../src/rxtx.serial.data.js","../src/rxtx.serial.port.js","../src/rxtx.serial.js","../src/rxtx.window.js","../src/rxtx.keyboard.js","../src/rxtx.debug.js","../src/rxtx.init.js","../src/main.js"],"sourcesContent":["/**\n * Parses a JSON string and returns the resulting object.\n * If parsing fails, it returns a default object with an `id` of -1.\n *\n * @param {string} theString - The JSON string to be parsed.\n * @returns {Object} - The parsed JSON object, or a default object \n * if parsing fails.\n */\nexport const parseStringToJSON = async (theString) => {\n  try {\n    let json = JSON.parse(theString);\n    return json;\n  } catch (error) {\n    return { id: -1 };\n  }\n};\n\n/**\n * Parses a string into an array of numbers or a single floating-point \n * number. If the string starts with '[', it is treated as a comma-separated \n * list of numbers. Otherwise, the string is parsed as a single float.\n *\n * @param {string} theData - The input string to be parsed.\n * @returns {number[]|number} - An array of numbers if the input represents a \n * list, or a single floating-point number if it does not.\n *\n * @example\n * parseStringToArray(\"[1, 2, 3]\"); // Returns [1, 2, 3]\n * parseStringToArray(\"42.5\");     // Returns 42.5\n */\nexport const parseStringToArray = (theData) => {\n  if (theData.charAt(0) == \"[\") {\n    let str0 = theData;\n    let str1 = str0.trim().replace(/[`\\[\\]\\\\\\/]/gi, \"\");\n    let arr0 = str1.split(\",\");\n    let arr1 = arr0.map(Number);\n    return arr1;\n  } else {\n    // @TODO do we want that here or should this default\n    // to an array with a single element.\n    return float(theData);\n  }\n};\n\n/**\n * Converts a string to an ArrayBuffer.\n *\n * This function takes a string and encodes it into an ArrayBuffer where each \n * character is represented by 2 bytes (UTF-16). The resulting ArrayBuffer can \n * be used for binary data manipulation.\n *\n * @param {string} theString - The input string to be converted.\n * @returns {ArrayBuffer} The resulting ArrayBuffer containing the encoded string.\n *\n * Example:\n * const buffer = str2ab(\"hello\");\n * console.log(buffer); // ArrayBuffer { byteLength: 10 }\n */\nexport const str2ab = (theString) => {\n  var buf = new ArrayBuffer(theString.length * 2); // 2 bytes for each char\n  var bufView = new Uint16Array(buf);\n  for (var i = 0, strLen = theString.length; i < strLen; i++) {\n    bufView[i] = theString.charCodeAt(i);\n  }\n  return buf;\n};\n\n/**\n * Recursively merges the properties of a source object into a target object.\n * If a property in the source is an object, it performs a deep merge. Arrays\n * are not deeply merged but overwritten. The target object is modified and\n * returned.\n *\n * @param {Object} target - The object to receive properties from the source.\n * @param {Object} source - The object whose properties are merged into the\n * target.\n * @returns {Object} - The modified target object after merging.\n *\n * @example\n * const target = { a: 1, b: { c: 2 } };\n * const source = { b: { d: 3 }, e: 4 };\n * const result = deepMerge(target, source);\n * console.log(result); // { a: 1, b: { c: 2, d: 3 }, e: 4 }\n */\nexport const deepMerge = (target, source) => {\n  for (const key in source) {\n    if (\n      source[key] && typeof source[key] === \"object\" &&\n      !Array.isArray(source[key])\n    ) {\n      target[key] = deepMerge(target[key] || {}, source[key]);\n    } else {\n      target[key] = source[key];\n    }\n  }\n  return target;\n};\n\n/**\n * Updates the given state object with new properties.\n * \n * This function merges the `updates` object into `theState` using\n * shallow copying. Existing properties in `theState` are overwritten \n * if they exist in `updates`, while new properties are added.\n * \n * @param {Object} theState - The state object to update.\n * @param {Object} updates - The object containing properties to merge\n *                           into the state.\n * \n * @example\n * const state = { a: 1, b: 2 };\n * updateState(state, { b: 3, c: 4 });\n * console.log(state); // { a: 1, b: 3, c: 4 }\n */\nexport const updateState = (theState, updates) => {\n  Object.assign(theState, updates);\n};\n\n/**\n * Generates a formatted timestamp string.\n *\n * This function constructs a timestamp in the format `YYYYMMDDHHmmSS` using\n * the current date and time. Each component (month, day, hour, minute, and\n * second) is zero-padded to ensure a consistent two-digit format.\n *\n * @returns {string} A timestamp string in the format `YYYYMMDDHHmmSS`.\n *\n * Example:\n *   If the current date and time is December 1, 2023, 15:05:09, the output\n *   will be: \"20231201150509\".\n */\nexport const getFormattedTimeStamp = () => {\n  let t = year() + nf(month(), 2) + nf(day(), 2);\n  t += nf(hour(), 2) + nf(minute(), 2) + nf(second(), 2);\n  return t;\n};\n","import { parseStringToJSON, updateState } from \"./rxtx.processing\";\n\n/**\n * Sends data to the connected serial device via the Web Serial API.\n *\n * @async\n * @function rxtxWriteTo\n * @param {Object} theState - The current application state, including the\n *                            serial port and writer.\n * @param {*} theData - The data to be sent to the serial device. This data\n *                      will be processed before being written.\n * @returns {Promise<boolean>} Returns true if the data was successfully sent,\n *                             or false if no port is available in the state.\n *\n * @example\n * const state = { port: somePort, writer: someWriter };\n * const success = await rxtxWriteTo(state, \"Hello Device\");\n * console.log(success); // true if data was sent successfully\n */\nexport const rxtxWriteTo = async (theState, theData) => {\n  if (!theState?.port) return false;\n  await theState.writer.write(checkRxtxData(theData));\n  return true;\n};\n\nconst checkRxtxData = (theData) => {\n  // see sketch https://editor.p5js.org/sojamo/sketches/yXZauy17X\n  // to type check, then operate on theData accordingly\n  // and return expected type so that it can be interpreted\n  // by the receiving end, the Arduino.\n  return utf8EncodeText.encode(theData);\n};\n\n/**\n * Processes incoming data from a serial stream, handling partial and complete\n * data chunks. Appends incomplete data to a buffer until a newline character\n * (`\\n`) is detected, at which point the buffer is parsed as JSON. Updates the\n * application state and triggers related events upon successful parsing.\n *\n * @param {string} value - Incoming data chunk from the serial stream.\n * @param {object} theState - Application state object that holds the buffer,\n *                            parsed data, and callback functions.\n *\n * @throws {Error} Logs an error if parsing the buffer as JSON fails.\n *\n * @example\n * handleIncomingData(\"[1,2,3]\\n\", theState);\n * // Parses \"[1,2,3]\" as JSON, updates the state, and triggers events.\n */\nexport const handleIncomingData = (value, theState) => {\n  if (!value.includes(\"\\n\")) {\n    theState.readBuffer += value;\n    return;\n  }\n  const [data, remainder] = value.split(\"\\n\");\n  theState.readBuffer += data;\n  parseStringToJSON(theState.readBuffer)\n    .then((parsedData) => {\n      if (parsedData.value !== undefined) {\n        // @TODO fix this messy looking data transfer\n        const { id, value } = parsedData;\n        theState.debug.data = { value, id };\n        updateState(theState, {\n          value: value || [],\n          id: id || -1,\n          // debug: { data: theState }, // @TODO look into this assignment, overrides debug settings\n        });\n\n        theState.fn({ id: theState.id, value: theState.value });\n        theState.rxtxEvent({ id: theState.id, value: theState.value });\n      }\n      theState.readBuffer = remainder || \"\";\n    })\n    .catch((err) => console.log(\"Error parsing data:\", err));\n};\n","import { handleIncomingData } from \"./rxtx.serial.data\";\nimport { updateState } from \"./rxtx.processing\";\n\n/**\n * Retrieves all available serial ports that the user has\n * previously granted permission to access.\n *\n * This function utilizes the Web Serial API to list serial\n * ports that are currently available and for which the browser\n * has retained user permissions. If the Web Serial API is not\n * supported by the browser, an error is thrown.\n *\n * @async\n * @function getAvailablePorts\n * @throws {Error} If the Web Serial API is not supported by the browser.\n * @returns {Promise<SerialPort[]>} A promise that resolves to an array\n *                                  of `SerialPort` objects representing\n *                                  the available serial ports.\n */\nexport const getAvailablePorts = async () => {\n  if (!(\"serial\" in navigator)) {\n    throw new Error(\"Web Serial API not supported.\");\n  }\n  return await navigator.serial.getPorts();\n};\n\n/**\n * Attempts to reconnect to all previously granted serial ports.\n *\n * This function retrieves a list of previously granted serial ports using\n * `getAvailablePorts`, then iterates over each port to establish a connection\n * by calling `connectToPort`. The state (`theState`) is updated during each\n * connection attempt.\n *\n * @async\n * @param {Object} theState - The application state object used to manage\n *                            connections and serial port details.\n */\nexport const reconnectToPreviouslyGrantedPorts = async (theState) => {\n  const ports = await getAvailablePorts();\n  console.log(\"trying to reconnect to previous ports\", ports);\n  for (const port of ports) {\n    await connectToPort(port, theState);\n  }\n};\n\n/**\n * Checks and establishes a connection to a serial port for the given state.\n *\n * This function initializes the `readBuffer` in the provided state and attempts\n * to retrieve available serial ports. If no ports are available, it prompts\n * the user to select a port. Otherwise, it selects the first available port.\n * Once a port is identified, the function attempts to connect to it.\n *\n * @async\n * @function checkPortConnectionFor\n * @param {Object} theState - The application state object. It should contain\n *                            the required properties for managing the serial\n *                            connection and the read buffer.\n * @returns {Promise<boolean>} - Resolves to `true` if the connection is\n *                               successfully established; otherwise, `false`.\n */\nexport const checkPortConnectionFor = async (theState) => {\n  theState.readBuffer = \"\";\n\n  // Get available ports\n  const ports = await getAvailablePorts();\n\n  let port;\n  if (ports.length === 0) {\n    // Select a port if none are available\n    port = await selectPort();\n  } else {\n    // Select the first port available from the ports list\n    port = ports[0];\n  }\n  return await connectToPort(port, theState);\n};\n\n/**\n * Prompts the user to select a serial port using the Web Serial API.\n *\n * This function uses `navigator.serial.requestPort()` to request a serial\n * port from the user. If the user selects a port, the function resolves with\n * the selected port. If an error occurs or the user cancels the selection, the\n * function logs the error and explicitly returns `undefined`.\n *\n * @returns {Promise<SerialPort | undefined>} A promise that resolves with the\n * selected `SerialPort` object if successful, or `undefined` if an error\n * occurs or no port is selected.\n */\nconst selectPort = async () => {\n  try {\n    // Request a port from the user\n    const port = await navigator.serial.requestPort();\n    return port; // Return the selected port\n  } catch (err) {\n    console.log(\"Error selecting port:\", err);\n    return undefined; // Explicitly return undefined on error\n  }\n};\n\n/**\n * Asynchronously connects to a given serial port and updates the state object.\n *\n * This function opens the specified serial port with the baud rate provided in\n * the state object. It sets up the necessary streams for reading and writing\n * data, stores the connection details, and initiates data reading from the port.\n * If the connection is successful, the state is updated accordingly.\n *\n * @async\n * @function connectToPort\n * @param {SerialPort} thePort - The serial port to connect to.\n * @param {Object} theState - The state object containing configuration and\n *                            where connection details will be stored.\n * @returns {Promise<boolean>} - Resolves to `true` if connection is successful,\n *                               otherwise `false`.\n *\n * @throws Will throw an error if the connection fails.\n */\nconst connectToPort = async (thePort, theState) => {\n  if (!thePort) {\n    console.log(\"No port provided.\");\n    return false;\n  }\n\n  try {\n    // Open the port with the given baud rate\n    await thePort.open({ baudRate: theState.baudRate });\n\n    // Set up text decoding for the readable stream\n    const decoder = new TextDecoderStream();\n    const inputDone = thePort.readable.pipeTo(decoder.writable);\n\n    // Retrieve reader and writer\n    const reader = decoder.readable.getReader();\n    const writer = thePort.writable.getWriter();\n\n    // Store the connected port and streams\n    theState.connectedPorts.push({ thePort, reader, writer });\n\n    // Log successful connection\n    console.log(\"Serial communication established with\", thePort.getInfo());\n\n    // Update the state\n    updateState(theState, {\n      connected: true,\n      port: thePort,\n      reader,\n      writer,\n      io: true, // @TODO: Decide if io is redundant\n    });\n\n    // Start reading from the port\n    await readFromPort(theState);\n\n    return true; // Indicate success\n  } catch (err) {\n    console.log(\"Error connecting to port:\", err);\n    cleanupResources(thePort, theState).then(() =>\n      console.log(\"Resources cleaned up.\")\n    ).catch(console.error);\n  }\n  return false;\n};\n\n/**\n * Reads data from the connected serial port in an asynchronous loop.\n *\n * Continuously reads incoming data from the port while the connection\n * remains active (`theState.connected`). Passes the data to a handler\n * function for processing. If an error occurs during reading, logs\n * the error and throws it for upstream handling. Ensures resources\n * like the reader and port are cleaned up when the reading stops or\n * an error occurs.\n *\n * @param {Object} theState - The application state object containing:\n *  - `connected` (boolean): Whether the port is connected.\n *  - `reader` (ReadableStreamDefaultReader): The port's reader for incoming data.\n *  - `port` (SerialPort): The connected serial port.\n *\n * @throws {Error} Re-throws any error encountered during reading.\n */\nconst readFromPort = async (theState) => {\n  try {\n    while (theState.connected) {\n      const { value, done } = await theState.reader.read();\n      if (done) break;\n      if (value) handleIncomingData(value, theState);\n    }\n  } catch (err) {\n    console.log(\"Error during read:\", err);\n    throw err;\n  } finally {\n    cleanupResources(theState.port, theState).then(() =>\n      console.log(\"Resources cleaned up.\")\n    ).catch(console.error);\n  }\n};\n\n/**\n * Cleans up serial port resources by canceling and releasing reader\n * and writer locks. Ensures proper closure of streams to prevent\n * resource leaks.\n *\n * @param {SerialPort} thePort - The serial port to be cleaned up (optional).\n * @param {Object} theState - The application state containing reader and writer.\n * @returns {Promise<void>} Resolves when cleanup is complete.\n */\nconst cleanupResources = async (thePort, theState) => {\n  // @TODO cleanup theState\n\n  try {\n    if (theState.reader) {\n      await theState.reader.cancel();\n      theState.reader.releaseLock();\n    }\n    if (theState.writer) {\n      await theState.writer.close();\n      theState.writer.releaseLock();\n    }\n  } catch (err) {\n    console.log(\"Error during cleanup:\", err);\n  }\n};\n","import {\n  checkPortConnectionFor,\n  getAvailablePorts,\n  reconnectToPreviouslyGrantedPorts,\n} from \"./rxtx.serial.port\";\n\n\n/**\n * Initializes the rxtx extension by checking available serial ports and managing\n * connection states. If no ports are detected, it adds a \"Connect\" button\n * to prompt the user for manual port selection. If ports are available, it\n * attempts to reconnect to previously granted ports.\n *\n * @async\n * @function startRxtxWith\n * @param {Object} theState - The application state object that holds serial\n *                            connection information and configurations.\n * @returns {Object} Updated state object after processing available ports.\n *\n */\n\nexport const startRxtxWith = async (theState) => {\n  const availablePorts = await getAvailablePorts();\n  // @TODO update state before returning\n  switch (availablePorts.length) {\n    case 0:\n      console.log(\"No previously granted ports detected, add connect button.\");\n      await addConnectButton(theState);\n      break;\n    default:\n      console.log(\"Previously granted ports detected, wait to reconnect ..\");\n      try {\n        await reconnectToPreviouslyGrantedPorts(theState);\n      } catch (err) {\n        console.log(\"couldn't reconnect to previously granted port(s).\");\n        await addConnectButton(theState);\n      }\n      break;\n  }\n  return theState;\n};\n\n/**\n * Adds a \"connect\" button to the interface for establishing a serial connection.\n *\n * The button is styled and positioned on the screen. When pressed, it attempts\n * to connect to a serial port using the provided state. If the connection fails,\n * the button is re-added for retrying. The button changes color on hover to\n * provide feedback to the user.\n *\n * @param {Object} theState - An object representing the current application state.\n *                            Includes configuration and callbacks for connection.\n *\n * Usage:\n * Call this function to display a \"connect\" button on the interface, allowing\n * users to establish a connection.\n */\n\nconst addConnectButton = async (theState) => {\n  // @TODO check if button already exists to avoid more \n  // than 1 instances at the same time\n  const button = createButton(\"connect\");\n  button.position(20, 20);\n  button.style(`\n    background: #03a1ff;\n    color: #fff;\n    font-size: 16px;\n    margin: auto;\n    border: 0;\n    padding: 8px 32px;\n    border-radius: 32px;\n    transition: background 0.3s;\n  `);\n\n  button.mouseOver(() => button.style(\"background: #06b004;\"));\n  button.mouseOut(() => button.style(\"background: #03a1ff;\"));\n\n  button.mousePressed(async () => {\n    theState.fn = (val) => {\n      // console.log(\"debug: \" + val);\n    };\n    button.remove();\n    try {\n      const isConnected = await checkPortConnectionFor(theState);\n      if (!isConnected) addConnectButton(theState);\n    } catch (err) {\n      console.log(err);\n    }\n  });\n};\n","/**\n * Toggles the application to enter fullscreen mode.\n *\n * This function checks if the application is not currently in fullscreen\n * mode using the `fullscreen()` function. If not in fullscreen, it switches\n * the application to fullscreen mode by setting `fullscreen(true)`.\n *\n * Note:\n * - This function assumes the presence of the `fullscreen()` utility, \n *   provided by p5.js.\n */\nexport const enterFullscreen = () => {\n  var fs = fullscreen();\n  if (!fs) {\n    fullscreen(true);\n  }\n};\n\n/**\n * Prevents touch move events on the document.\n *\n * This function disables the default behavior of touch move events,\n * such as scrolling or panning, when a user drags their finger across\n * the screen. Useful for applications where touch gestures should be\n * intercepted or restricted.\n *\n * @param {TouchEvent} event - The touch event triggered by a user's interaction.\n */\ndocument.ontouchmove = (event) => {\n  event.preventDefault();\n};","import { enterFullscreen } from \"./rxtx.window\";\nimport { getFormattedTimeStamp } from \"./rxtx.processing\";\n\n/**\n * Handles keypress events and updates the application state based on the\n * pressed key. Supports toggling debug modes, entering fullscreen,\n * and saving a canvas image. Checks for allowed keys and ensures state\n * consistency during keypress handling.\n * \n * Mapped keys can be dis/enabled with the mappedKeys option\n * @see initWith - Initializes the state with default, user-defined, settings\n *\n * @param {Object} theState - The current application state. Includes:\n *   - {boolean} isKeyPressed - Tracks whether a key is currently pressed.\n *   - {Object} debug - Manages debug settings:\n *       - {boolean} show - Toggles debug display.\n *       - {boolean} print - Toggles debug print mode.\n *   - {Array<string>} mappedKeys - Allowed keys for handling.\n *   - {Object} image - Contains image properties:\n *       - {string} format - File format for saved images.\n *       - {string} label - Prefix label for saved images.\n * \n */\nexport const keyPressed = (theState) => {\n  if (isKeyPressed === true) {\n    if (theState.isKeyPressed === false) {\n      theState.isKeyPressed = true;\n      if (!theState.mappedKeys.includes(key)) {\n        return;\n      }\n      switch (key) {\n        case \"d\":\n          theState.debug.show = !theState.debug.show;\n          break;\n        case \"f\":\n          enterFullscreen();\n          break;\n        case \"p\":\n          theState.debug.print = !theState.debug.print;\n          break;\n        case \"s\":\n          const l = theState.image.label;\n          const t = getFormattedTimeStamp();\n          const ext = theState.image.format;\n          let label = `${l}_${t}.${ext}`;\n          console.log(`saving image ${label}`);\n          saveCanvas(label, theState.image.format);\n          break;\n      }\n    }\n  } else {\n    theState.isKeyPressed = false;\n  }\n};\n","/**\n * Displays debugging information for the RXTX state.\n *\n * This function logs and visualizes the debug data stored in the `theState`\n * object. It first checks whether debugging options are enabled (`print` and\n * `show`) and whether valid data is available. If data is present and the\n * `show` option is enabled, a graphical layer is created or updated to display\n * the data as a list of visualized values on the canvas.\n *\n * The debug output includes:\n * - Text logging of debug data if `print` is enabled.\n * - A graphical representation of values, showing constrained bars and\n *   corresponding numeric labels.\n * - Integration with WebGL mode by offsetting the canvas transformation.\n *\n * @param {Object} theState - The state object containing debug information.\n */\nexport const showRxtxDebug = (theState) => {\n  if (theState.debug.print) {\n    if (theState.debug.data.value == undefined) {\n      console.log(\"debug.print, no data present yet.\");\n    } else {\n      console.log(theState.debug.data.value);\n    }\n  }\n  if (!theState.debug.show || !theState.debug.data.value) return;\n\n  const isWEBGL = drawingContext instanceof WebGLRenderingContext;\n\n  const v = theState.debug.data.value;\n  const id = theState.debug.data.id;\n  const label = `Device ${id}`;\n  const spacing = 20;\n  const header = 40;\n  const footer = 20;\n  const h = header + v.length * spacing + footer;\n  const w = 400;\n  if (!theState.debug.layer) {\n    theState.debug.layer = createGraphics(w, h);\n    theState.debug.layer.clear();\n  }\n  const l = theState.debug.layer;\n  l.clear();\n  l.noStroke();\n  l.fill(0, 40);\n  l.rect(0, 0, w, h, 16);\n  l.push();\n  l.translate(20, 20);\n  l.fill(255);\n  l.text(label, 0, 0);\n  l.translate(0, 20);\n  v.forEach((v, i) => {\n    let v0 = constrain(v, 0, 1);\n    l.push();\n    l.translate(0, i * 20);\n    l.fill(255, 40);\n    l.rect(0, 0, 300, 10, 4);\n    l.fill(255, 200);\n    l.rect(0, 2, v0 * 300, 8, 4);\n    l.fill(255);\n    l.text(v0.toFixed(2), 320, 10);\n    l.pop();\n  });\n  l.pop();\n\n  push();\n  if (isWEBGL) {\n    translate(-width / 2, -height / 2);\n  }\n  translate(20, 20);\n  image(theState.debug.layer, 0, 0);\n  pop();\n};\n\nexport const log = (...args) => {\n  let msg = ``;\n  args.forEach((el) => {\n    if (el instanceof Object) {\n      msg += `\\n${JSON.stringify(el, null, 2)}`;\n    } else {\n      msg += el;\n    }\n  });\n  console.log(\"rxtx debug : \", msg);\n};\n","import { deepMerge, updateState } from \"./rxtx.processing\";\nimport { startRxtxWith } from \"./rxtx.serial\";\nimport { keyPressed } from \"./rxtx.keyboard\";\nimport { showRxtxDebug } from \"./rxtx.debug\";\n\n/**\n * Initializes the application state with default, user-defined, and internal\n * settings. Merges these settings into `theState` and starts the rxtx process.\n *\n * @param {Object} theApp - The application instance (sketch or object), expected to\n *                          provide properties such as `rxtxEvent` for handling events.\n * @param {Object} theArgs - User-defined settings that override default values.\n *                           Example properties include:\n *                           - baudRate: Communication speed (default: 57600).\n *                           - id: Identifier for the state (default: -1).\n *                           - value: Array of values (default: []).\n *                           - debug: Debugging options { print: false, show: false }.\n * @param {Object} theState - The state object to be initialized with the merged\n *                            settings, including default, user-defined, and\n *                            internal configurations.\n */\nexport const initWith = (theApp, theArgs, theState) => {\n  const defaults = {\n    baudRate: 57600,\n    id: -1,\n    value: [],\n    fn: (ev) => {},\n    image: {\n      label: \"rxtx\",\n      format: \"jpg\",\n    },\n    mappedKeys: [\"d\",\"f\",\"p\",\"s\"],\n    debug: { print: false, show: false },\n  };\n\n  const internal = {\n    debug: { data: {} },\n    connected: false,\n    io: null,\n    isKeyPressed: false,\n    rxtxEvent: theApp.rxtxEvent || ((ev) => {}),\n    readBuffer: \"\",\n    connectedPorts: [],\n  };\n\n  updateState(theState, deepMerge(deepMerge(defaults, theArgs), internal));\n  startRxtxWith(theState);\n};\n\n/**\n * Performs an environment check for the p5.js instance and registers \n * custom behaviors for the window resize and specific \"post\" methods. \n * If p5.js is not found in the global scope, an error is logged.\n * \n * @param {object} theInstance - The global object to check for p5.js.\n * @param {object} theState - The application state object used for \n *                            handling key press and debugging behaviors.\n * \n * - Registers a `windowResized` function to resize the canvas dynamically.\n * - Registers \"post\" methods for handling key presses and debugging.\n * - Logs an error if p5.js is not available in the environment.\n * \n */\nexport const environmentCheck = (theInstance, theState) => {\n  (function (global) {\n    if (global.p5) {\n      global.p5.prototype.windowResized = () => {\n        resizeCanvas(windowWidth, windowHeight);\n      };\n\n      global.p5.prototype.registerMethod(\"post\", () => keyPressed(theState));\n      global.p5.prototype.registerMethod(\"post\", () => showRxtxDebug(theState));\n    } else {\n      console.error(\n        \"p5.js not found. Please include p5.js before this library.\",\n      );\n    }\n  })(theInstance);\n};\n","import { environmentCheck, initWith } from \"./rxtx.init\";\n\nconst state = {};\n\n/**\n * Initializes the rxtx connection with the specified app and options.\n *\n * This function sets up the rxtx extension for communication using the provided\n * p5.js sketch and configuration options. It should be called from the\n * `setup` function of your sketch. The configuration options allow for\n * customization of the baud rate, debugging behavior, and other settings.\n *\n * @param {object} theApp - The p5.js sketch instance (`this` from the sketch).\n * @param {object} [theArgs={}] - Configuration options for the connection.\n *\n * @example\n * // Call this function in your p5.js setup function:\n * let options = {\n *   baudRate: 57600,\n *   debug: { print: false, show: false },\n * };\n * rxtx.connect(this, options);\n *\n * @public\n */\nexport const connect = async (theApp, theArgs = {}) => {\n  initWith(theApp, theArgs, state);\n};\n\n/**\n * Checks if values are available in the RXTX state.\n *\n * This function verifies if the `value` field in the RXTX state is defined.\n * Returns `true` if values are available, otherwise `false`. It is designed\n * to be called frequently, such as within a p5.js `draw` function.\n *\n * Usage Example:\n * function draw() {\n *   background(220);\n *\n *   if (rxtx.isValuesAvailable()) {\n *     if (rxtx.getValueAt(0) === 1) {\n *       background(0);\n *     }\n *   }\n *   ...etc\n * }\n *\n * @returns {boolean} `true` if values are available, `false` otherwise.\n * @public\n */\nexport const isValuesAvailable = () => {\n  return state.debug.data.value == undefined ? false : true;\n};\n\nexport const isConnectionEstablished = () => {\n  return state.connected;\n};\n\nexport const isReadyToWrite = () => {\n  return state.io != null;\n};\n\n/**\n * Retrieves the value at the specified index from a list of values.\n *\n * If the index is out of bounds (greater than or equal to the length of\n * the values array), it returns -1. Otherwise, it returns the value\n * at the given index.\n *\n * @param {number} theIndex - The index of the value to retrieve.\n * @returns {*} The value at the specified index, or -1 if out of bounds.\n */\nexport const getValueAt = (theIndex) => {\n  const values = getValues();\n  return theIndex >= values.length ? -1 : values[theIndex];\n};\n\n/**\n * Retrieves the current values from the application state.\n *\n * This function returns the `value` property from the global `state` object.\n * If the `value` property is undefined or null, it defaults to an empty array.\n *\n * @returns {Array} - An array of current values or an empty array if no values\n *                    are set in the state.\n */\nexport const getValues = () => {\n  return state.value || [];\n};\n\n/**\n * Checks the runtime environment for necessary conditions and updates the\n * application state accordingly.\n *\n * @param {Window} window - The global window object, used for browser-related\n * checks.\n * @param {Object} state - The application state object to be updated based on\n * the environment check results.\n *\n * This function verifies if the runtime environment supports the required APIs\n * or features (e.g., Web Serial API) and updates the provided state object\n * with relevant flags or properties, enabling other parts of the application\n * to adapt to the current environment.\n *\n */\nenvironmentCheck(window, state);\n"],"names":["key","value","v"],"mappings":"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"}